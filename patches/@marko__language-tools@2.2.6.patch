diff --git a/dist/index.js b/dist/index.js
index 0bb69200b597f10a3c541320c85db7ccdc892905..06e777d06d7b4c5689cc981e4d357e310849a873 100644
--- a/dist/index.js
+++ b/dist/index.js
@@ -10,22 +10,31 @@ var __export = (target, all) => {
     __defProp(target, name, { get: all[name], enumerable: true });
 };
 var __copyProps = (to, from, except, desc) => {
-  if (from && typeof from === "object" || typeof from === "function") {
+  if ((from && typeof from === "object") || typeof from === "function") {
     for (let key of __getOwnPropNames(from))
       if (!__hasOwnProp.call(to, key) && key !== except)
-        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
+        __defProp(to, key, {
+          get: () => from[key],
+          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
+        });
   }
   return to;
 };
-var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
-  // If the importer is in node compatibility mode or this is not an ESM
-  // file that has been converted to a CommonJS file using a Babel-
-  // compatible transform (i.e. "__esModule" has not been set), then set
-  // "default" to the CommonJS "module.exports" for node compatibility.
-  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
-  mod
-));
-var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
+var __toESM = (mod, isNodeMode, target) => (
+  (target = mod != null ? __create(__getProtoOf(mod)) : {}),
+  __copyProps(
+    // If the importer is in node compatibility mode or this is not an ESM
+    // file that has been converted to a CommonJS file using a Babel-
+    // compatible transform (i.e. "__esModule" has not been set), then set
+    // "default" to the CommonJS "module.exports" for node compatibility.
+    isNodeMode || !mod || !mod.__esModule
+      ? __defProp(target, "default", { value: mod, enumerable: true })
+      : target,
+    mod
+  )
+);
+var __toCommonJS = (mod) =>
+  __copyProps(__defProp({}, "__esModule", { value: true }), mod);
 
 // src/index.ts
 var src_exports = {};
@@ -43,7 +52,7 @@ __export(src_exports, {
   getLocation: () => import_htmljs_parser2.getLocation,
   getPosition: () => import_htmljs_parser2.getPosition,
   isDefinitionFile: () => isDefinitionFile,
-  parse: () => parse
+  parse: () => parse,
 });
 module.exports = __toCommonJS(src_exports);
 
@@ -53,8 +62,7 @@ var import_htmljs_parser = require("htmljs-parser");
 // src/util/get-node-at-offset.ts
 function getNodeAtOffset(offset, program) {
   const childNode = childAtOffset(offset, program.body);
-  if (childNode)
-    return visitChildNode(offset, childNode);
+  if (childNode) return visitChildNode(offset, childNode);
   return childAtOffset(offset, program.static) || program;
 }
 function visitChildNode(offset, child) {
@@ -118,11 +126,10 @@ function visitAttrNode(offset, attr) {
 }
 function childAtOffset(offset, children) {
   let max = children.length - 1;
-  if (max === -1)
-    return void 0;
+  if (max === -1) return void 0;
   let min = 0;
   while (min < max) {
-    const mid = 1 + min + max >>> 1;
+    const mid = (1 + min + max) >>> 1;
     if (children[mid].start < offset) {
       min = mid;
     } else {
@@ -138,35 +145,35 @@ var import_htmljs_parser2 = require("htmljs-parser");
 var styleBlockReg = /((?:\.[^\s\\/:*?"<>|({]+)*)\s*\{/y;
 var UNFINISHED = Number.MAX_SAFE_INTEGER;
 var NodeType = /* @__PURE__ */ ((NodeType2) => {
-  NodeType2[NodeType2["Program"] = 0] = "Program";
-  NodeType2[NodeType2["Tag"] = 1] = "Tag";
-  NodeType2[NodeType2["OpenTagName"] = 2] = "OpenTagName";
-  NodeType2[NodeType2["ShorthandId"] = 3] = "ShorthandId";
-  NodeType2[NodeType2["ShorthandClassName"] = 4] = "ShorthandClassName";
-  NodeType2[NodeType2["TagTypeArgs"] = 5] = "TagTypeArgs";
-  NodeType2[NodeType2["TagTypeParams"] = 6] = "TagTypeParams";
-  NodeType2[NodeType2["TagVar"] = 7] = "TagVar";
-  NodeType2[NodeType2["TagArgs"] = 8] = "TagArgs";
-  NodeType2[NodeType2["TagParams"] = 9] = "TagParams";
-  NodeType2[NodeType2["AttrNamed"] = 10] = "AttrNamed";
-  NodeType2[NodeType2["AttrName"] = 11] = "AttrName";
-  NodeType2[NodeType2["AttrArgs"] = 12] = "AttrArgs";
-  NodeType2[NodeType2["AttrValue"] = 13] = "AttrValue";
-  NodeType2[NodeType2["AttrMethod"] = 14] = "AttrMethod";
-  NodeType2[NodeType2["AttrSpread"] = 15] = "AttrSpread";
-  NodeType2[NodeType2["AttrTag"] = 16] = "AttrTag";
-  NodeType2[NodeType2["Text"] = 17] = "Text";
-  NodeType2[NodeType2["CDATA"] = 18] = "CDATA";
-  NodeType2[NodeType2["Doctype"] = 19] = "Doctype";
-  NodeType2[NodeType2["Declaration"] = 20] = "Declaration";
-  NodeType2[NodeType2["Comment"] = 21] = "Comment";
-  NodeType2[NodeType2["Placeholder"] = 22] = "Placeholder";
-  NodeType2[NodeType2["Scriptlet"] = 23] = "Scriptlet";
-  NodeType2[NodeType2["Import"] = 24] = "Import";
-  NodeType2[NodeType2["Export"] = 25] = "Export";
-  NodeType2[NodeType2["Class"] = 26] = "Class";
-  NodeType2[NodeType2["Style"] = 27] = "Style";
-  NodeType2[NodeType2["Static"] = 28] = "Static";
+  NodeType2[(NodeType2["Program"] = 0)] = "Program";
+  NodeType2[(NodeType2["Tag"] = 1)] = "Tag";
+  NodeType2[(NodeType2["OpenTagName"] = 2)] = "OpenTagName";
+  NodeType2[(NodeType2["ShorthandId"] = 3)] = "ShorthandId";
+  NodeType2[(NodeType2["ShorthandClassName"] = 4)] = "ShorthandClassName";
+  NodeType2[(NodeType2["TagTypeArgs"] = 5)] = "TagTypeArgs";
+  NodeType2[(NodeType2["TagTypeParams"] = 6)] = "TagTypeParams";
+  NodeType2[(NodeType2["TagVar"] = 7)] = "TagVar";
+  NodeType2[(NodeType2["TagArgs"] = 8)] = "TagArgs";
+  NodeType2[(NodeType2["TagParams"] = 9)] = "TagParams";
+  NodeType2[(NodeType2["AttrNamed"] = 10)] = "AttrNamed";
+  NodeType2[(NodeType2["AttrName"] = 11)] = "AttrName";
+  NodeType2[(NodeType2["AttrArgs"] = 12)] = "AttrArgs";
+  NodeType2[(NodeType2["AttrValue"] = 13)] = "AttrValue";
+  NodeType2[(NodeType2["AttrMethod"] = 14)] = "AttrMethod";
+  NodeType2[(NodeType2["AttrSpread"] = 15)] = "AttrSpread";
+  NodeType2[(NodeType2["AttrTag"] = 16)] = "AttrTag";
+  NodeType2[(NodeType2["Text"] = 17)] = "Text";
+  NodeType2[(NodeType2["CDATA"] = 18)] = "CDATA";
+  NodeType2[(NodeType2["Doctype"] = 19)] = "Doctype";
+  NodeType2[(NodeType2["Declaration"] = 20)] = "Declaration";
+  NodeType2[(NodeType2["Comment"] = 21)] = "Comment";
+  NodeType2[(NodeType2["Placeholder"] = 22)] = "Placeholder";
+  NodeType2[(NodeType2["Scriptlet"] = 23)] = "Scriptlet";
+  NodeType2[(NodeType2["Import"] = 24)] = "Import";
+  NodeType2[(NodeType2["Export"] = 25)] = "Export";
+  NodeType2[(NodeType2["Class"] = 26)] = "Class";
+  NodeType2[(NodeType2["Style"] = 27)] = "Style";
+  NodeType2[(NodeType2["Static"] = 28)] = "Static";
   return NodeType2;
 })(NodeType || {});
 function parse(code, filename = "index.marko") {
@@ -181,7 +188,8 @@ function parse(code, filename = "index.marko") {
     nodeAt: (offset) => getNodeAtOffset(offset, program),
     filename,
     program,
-    code
+    code,
+    errors: builder.errors,
   };
 }
 var Builder = class {
@@ -192,6 +200,7 @@ var Builder = class {
   #staticNode;
   #attrNode;
   #comments;
+  errors;
   constructor(code) {
     this.#code = code;
     this.#program = this.#parentNode = {
@@ -201,19 +210,26 @@ var Builder = class {
       static: [],
       body: [],
       start: 0,
-      end: code.length
+      end: code.length,
     };
   }
   end() {
     this.#program.comments = this.#comments;
     return this.#program;
   }
+  onError(range) {
+    if (this.errors) {
+      this.errors.push(range);
+    } else {
+      this.errors = [range];
+    }
+  }
   onText(range) {
     pushBody(this.#parentNode, {
       type: 17 /* Text */,
       parent: this.#parentNode,
       start: range.start,
-      end: range.end
+      end: range.end,
     });
   }
   onCDATA(range) {
@@ -222,7 +238,7 @@ var Builder = class {
       parent: this.#parentNode,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     });
   }
   onDoctype(range) {
@@ -231,7 +247,7 @@ var Builder = class {
       parent: this.#parentNode,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     });
   }
   onDeclaration(range) {
@@ -240,7 +256,7 @@ var Builder = class {
       parent: this.#parentNode,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     });
   }
   onComment(range) {
@@ -249,7 +265,7 @@ var Builder = class {
       parent: this.#parentNode,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
     if (this.#comments) {
       this.#comments.push(comment);
@@ -265,7 +281,7 @@ var Builder = class {
       value: range.value,
       escape: range.escape,
       start: range.start,
-      end: range.end
+      end: range.end,
     });
     this.#comments = void 0;
   }
@@ -277,7 +293,7 @@ var Builder = class {
       value: range.value,
       block: range.block,
       start: range.start,
-      end: range.end
+      end: range.end,
     });
     this.#comments = void 0;
   }
@@ -287,7 +303,7 @@ var Builder = class {
   onOpenTagName(range) {
     let concise = true;
     let start = range.start;
-    let type = 1 /* Tag */;
+    let type = 1; /* Tag */
     let bodyType = import_htmljs_parser.TagType.html;
     let nameText = void 0;
     if (this.#openTagStart) {
@@ -296,25 +312,25 @@ var Builder = class {
       this.#openTagStart = void 0;
     }
     if (!range.expressions.length) {
-      switch (nameText = this.#code.slice(range.start, range.end)) {
+      switch ((nameText = this.#code.slice(range.start, range.end))) {
         case "style": {
           styleBlockReg.lastIndex = range.end;
           const styleBlockMatch = styleBlockReg.exec(this.#code);
           if (styleBlockMatch) {
             const [{ length }, ext] = styleBlockMatch;
             this.#program.static.push(
-              this.#staticNode = {
+              (this.#staticNode = {
                 type: 27 /* Style */,
                 parent: this.#program,
                 comments: this.#comments,
                 ext: ext || void 0,
                 value: {
                   start: range.end + length,
-                  end: UNFINISHED
+                  end: UNFINISHED,
                 },
                 start: range.start,
-                end: UNFINISHED
-              }
+                end: UNFINISHED,
+              })
             );
             this.#comments = void 0;
             return import_htmljs_parser.TagType.statement;
@@ -325,49 +341,49 @@ var Builder = class {
         }
         case "class":
           this.#program.static.push(
-            this.#staticNode = {
+            (this.#staticNode = {
               type: 26 /* Class */,
               parent: this.#program,
               comments: this.#comments,
               start: range.start,
-              end: UNFINISHED
-            }
+              end: UNFINISHED,
+            })
           );
           this.#comments = void 0;
           return import_htmljs_parser.TagType.statement;
         case "export":
           this.#program.static.push(
-            this.#staticNode = {
+            (this.#staticNode = {
               type: 25 /* Export */,
               parent: this.#program,
               comments: this.#comments,
               start: range.start,
-              end: UNFINISHED
-            }
+              end: UNFINISHED,
+            })
           );
           this.#comments = void 0;
           return import_htmljs_parser.TagType.statement;
         case "import":
           this.#program.static.push(
-            this.#staticNode = {
+            (this.#staticNode = {
               type: 24 /* Import */,
               parent: this.#program,
               comments: this.#comments,
               start: range.start,
-              end: UNFINISHED
-            }
+              end: UNFINISHED,
+            })
           );
           this.#comments = void 0;
           return import_htmljs_parser.TagType.statement;
         case "static":
           this.#program.static.push(
-            this.#staticNode = {
+            (this.#staticNode = {
               type: 28 /* Static */,
               parent: this.#program,
               comments: this.#comments,
               start: range.start,
-              end: UNFINISHED
-            }
+              end: UNFINISHED,
+            })
           );
           this.#comments = void 0;
           return import_htmljs_parser.TagType.statement;
@@ -407,33 +423,36 @@ var Builder = class {
       quasis: range.quasis,
       expressions: range.expressions,
       start: range.start,
-      end: range.end
-    };
-    const tag = this.#parentNode = name.parent = {
-      type,
-      parent,
-      comments: this.#comments,
-      owner: void 0,
-      concise,
-      selfClosed: false,
-      hasAttrTags: false,
-      open: { start, end },
-      nameText,
-      name,
-      var: void 0,
-      args: void 0,
-      params: void 0,
-      shorthandId: void 0,
-      shorthandClassNames: void 0,
-      typeArgs: void 0,
-      typeParams: void 0,
-      attrs: void 0,
-      bodyType,
-      body: void 0,
-      close: void 0,
-      start,
-      end
+      end: range.end,
     };
+    const tag =
+      (this.#parentNode =
+      name.parent =
+        {
+          type,
+          parent,
+          comments: this.#comments,
+          owner: void 0,
+          concise,
+          selfClosed: false,
+          hasAttrTags: false,
+          open: { start, end },
+          nameText,
+          name,
+          var: void 0,
+          args: void 0,
+          params: void 0,
+          shorthandId: void 0,
+          shorthandClassNames: void 0,
+          typeArgs: void 0,
+          typeParams: void 0,
+          attrs: void 0,
+          bodyType,
+          body: void 0,
+          close: void 0,
+          start,
+          end,
+        });
     this.#comments = void 0;
     if (tag.type === 16 /* AttrTag */) {
       let parentTag = parent;
@@ -468,7 +487,7 @@ var Builder = class {
       quasis: range.quasis,
       expressions: range.expressions,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
   }
   onTagShorthandClass(range) {
@@ -479,7 +498,7 @@ var Builder = class {
       quasis: range.quasis,
       expressions: range.expressions,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
     if (parent.shorthandClassNames) {
       parent.shorthandClassNames.push(shorthandClassName);
@@ -494,7 +513,7 @@ var Builder = class {
       parent,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
   }
   onTagTypeParams(range) {
@@ -504,7 +523,7 @@ var Builder = class {
       parent,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
   }
   onTagVar(range) {
@@ -514,7 +533,7 @@ var Builder = class {
       parent,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
   }
   onTagParams(range) {
@@ -524,7 +543,7 @@ var Builder = class {
       parent,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
   }
   onTagArgs(range) {
@@ -534,7 +553,7 @@ var Builder = class {
       parent,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
   }
   onAttrName(range) {
@@ -543,19 +562,20 @@ var Builder = class {
       type: 11 /* AttrName */,
       parent: void 0,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
     pushAttr(
       parent,
-      this.#attrNode = name.parent = {
-        type: 10 /* AttrNamed */,
-        parent,
-        name,
-        value: void 0,
-        args: void 0,
-        start: range.start,
-        end: range.end
-      }
+      (this.#attrNode = name.parent =
+        {
+          type: 10 /* AttrNamed */,
+          parent,
+          name,
+          value: void 0,
+          args: void 0,
+          start: range.start,
+          end: range.end,
+        })
     );
   }
   onAttrArgs(range) {
@@ -565,7 +585,7 @@ var Builder = class {
       parent,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
     parent.end = range.end;
   }
@@ -577,7 +597,7 @@ var Builder = class {
       value: range.value,
       bound: range.bound,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
     parent.end = range.end;
   }
@@ -590,7 +610,7 @@ var Builder = class {
       params: range.params,
       body: range.body,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
     parent.end = range.end;
   }
@@ -601,7 +621,7 @@ var Builder = class {
       parent,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     });
   }
   onOpenTagEnd(range) {
@@ -615,7 +635,10 @@ var Builder = class {
       this.#attrNode = void 0;
       const tag = this.#parentNode;
       tag.open.end = range.end;
-      if (range.selfClosed || tag.bodyType === import_htmljs_parser.TagType.void) {
+      if (
+        range.selfClosed ||
+        tag.bodyType === import_htmljs_parser.TagType.void
+      ) {
         this.#parentNode = tag.parent;
         tag.end = range.end;
         tag.selfClosed = range.selfClosed;
@@ -625,13 +648,12 @@ var Builder = class {
   onCloseTagStart(range) {
     this.#parentNode.close = {
       start: range.start,
-      end: UNFINISHED
+      end: UNFINISHED,
     };
   }
   onCloseTagEnd(range) {
     const parent = this.#parentNode;
-    if (hasCloseTag(parent))
-      parent.close.end = range.end;
+    if (hasCloseTag(parent)) parent.close.end = range.end;
     parent.end = range.end;
     this.#parentNode = parent.parent;
   }
@@ -673,12 +695,12 @@ var emptyView = {
   },
   rangeAt(_start, _end) {
     return;
-  }
+  },
 };
 var Extractor = class {
   #parsed;
   #generated = "";
-  #tokens = [];
+  tokens = [];
   constructor(parsed) {
     this.#parsed = parsed;
   }
@@ -691,10 +713,10 @@ var Extractor = class {
       if (typeof range === "string") {
         this.#generated += range;
       } else {
-        this.#tokens.push({
+        this.tokens.push({
           generatedStart: this.#generated.length,
           sourceStart: range.start,
-          length: Math.min(this.#parsed.code.length, range.end) - range.start
+          length: Math.min(this.#parsed.code.length, range.end) - range.start,
         });
         this.#generated += this.#parsed.read(range);
       }
@@ -702,13 +724,14 @@ var Extractor = class {
     return this;
   }
   end() {
-    return new Extracted(this.#parsed, this.#generated, this.#tokens);
+    return new Extracted(this.#parsed, this.#generated, this.tokens);
   }
 };
 var Extracted = class {
   constructor(parsed, generated, tokens) {
     this.parsed = parsed;
     this.#generated = generated;
+    this.tokens = tokens;
     if (tokens.length === 0) {
       this.#generatedToSource = this.#sourceToGenerated = emptyView;
     } else {
@@ -723,15 +746,19 @@ var Extracted = class {
   #generatedToSource;
   #cachedGeneratedLines;
   get #generatedLines() {
-    return this.#cachedGeneratedLines || (this.#cachedGeneratedLines = (0, import_htmljs_parser2.getLines)(this.#generated));
+    return (
+      this.#cachedGeneratedLines ||
+      (this.#cachedGeneratedLines = (0, import_htmljs_parser2.getLines)(
+        this.#generated
+      ))
+    );
   }
   sourceOffsetAt(generatedOffset) {
     return this.#generatedToSource.offsetAt(generatedOffset);
   }
   sourcePositionAt(generatedOffset) {
     const sourceOffset = this.sourceOffsetAt(generatedOffset);
-    if (sourceOffset !== void 0)
-      return this.parsed.positionAt(sourceOffset);
+    if (sourceOffset !== void 0) return this.parsed.positionAt(sourceOffset);
   }
   sourceLocationAt(generatedStart, generatedEnd) {
     const sourceRange = this.#generatedToSource.rangeAt(
@@ -748,7 +775,10 @@ var Extracted = class {
   generatedPositionAt(sourceOffset) {
     const generatedOffset = this.generatedOffsetAt(sourceOffset);
     if (generatedOffset !== void 0) {
-      return (0, import_htmljs_parser2.getPosition)(this.#generatedLines, generatedOffset);
+      return (0, import_htmljs_parser2.getPosition)(
+        this.#generatedLines,
+        generatedOffset
+      );
     }
   }
   generatedLocationAt(sourceStart, sourceEnd) {
@@ -769,24 +799,24 @@ var Extracted = class {
   }
 };
 var TokenView = class {
-  #tokens;
+  tokens;
   #last;
   constructor(tokens) {
-    this.#tokens = tokens;
+    this.tokens = tokens;
     this.#last = tokens.length - 1;
   }
   offsetAt(offset) {
     let min = 0;
     let max = this.#last;
     while (min < max) {
-      const mid = 1 + min + max >>> 1;
-      if (this.inStart(this.#tokens[mid]) <= offset) {
+      const mid = (1 + min + max) >>> 1;
+      if (this.inStart(this.tokens[mid]) <= offset) {
         min = mid;
       } else {
         max = mid - 1;
       }
     }
-    const token = this.#tokens[min];
+    const token = this.tokens[min];
     const index = offset - this.inStart(token);
     if (index >= 0 && index <= token.length) {
       return this.outStart(token) + index;
@@ -796,8 +826,8 @@ var TokenView = class {
     let min = 0;
     let max = this.#last;
     while (min < max) {
-      const mid = min + max >> 1;
-      const token = this.#tokens[mid];
+      const mid = (min + max) >> 1;
+      const token = this.tokens[mid];
       const tokenInEnd = this.inStart(token) + token.length;
       if (tokenInEnd > inStart) {
         max = mid;
@@ -805,14 +835,13 @@ var TokenView = class {
         min = mid + 1;
       }
     }
-    const startToken = this.#tokens[max];
+    const startToken = this.tokens[max];
     const startTokenInStart = this.inStart(startToken);
-    if (startTokenInStart >= inEnd)
-      return;
+    if (startTokenInStart >= inEnd) return;
     max = this.#last;
     while (min < max) {
-      const mid = 1 + min + max >>> 1;
-      const token = this.#tokens[mid];
+      const mid = (1 + min + max) >>> 1;
+      const token = this.tokens[mid];
       const tokenEnd = this.inStart(token) + token.length;
       if (tokenEnd <= inEnd) {
         min = mid;
@@ -820,11 +849,10 @@ var TokenView = class {
         max = mid - 1;
       }
     }
-    const endToken = this.#tokens[min];
+    const endToken = this.tokens[min];
     const endTokenInStart = this.inStart(endToken);
     const endTokenInEnd = endTokenInStart + endToken.length;
-    if (endTokenInEnd < inStart)
-      return;
+    if (endTokenInEnd < inStart) return;
     const startIndex = inStart - startTokenInStart;
     const endIndex = inEnd - endTokenInStart;
     const start = this.outStart(startToken) + Math.max(0, startIndex);
@@ -885,7 +913,9 @@ function extractStyle(opts) {
       case 1 /* Tag */:
         if (node.body) {
           if (node.nameText === "style") {
-            const ext = node.shorthandClassNames ? read(node.shorthandClassNames.at(-1)) : ".css";
+            const ext = node.shorthandClassNames
+              ? read(node.shorthandClassNames.at(-1))
+              : ".css";
             for (const child of node.body) {
               switch (child.type) {
                 case 17 /* Text */:
@@ -906,14 +936,28 @@ function extractStyle(opts) {
           for (const attr of node.attrs) {
             if (
               // Check for string literal attribute values.
-              attr.type === 10 /* AttrNamed */ && ((_a = attr.value) == null ? void 0 : _a.type) === 13 /* AttrValue */ && /^['"]$/.test(code[attr.value.value.start])
+              attr.type === 10 /* AttrNamed */ &&
+              ((_a = attr.value) == null ? void 0 : _a.type) ===
+                13 /* AttrValue */ &&
+              /^['"]$/.test(code[attr.value.value.start])
             ) {
               const name = read(attr.name);
-              if (name === "#style" || name === "style" && node.nameText && name === "style" && ((_b = lookup.getTag(node.nameText)) == null ? void 0 : _b.html)) {
-                getExtractor("css").write(":root{").copy({
-                  start: attr.value.value.start + 1,
-                  end: attr.value.value.end - 1
-                }).write("}");
+              if (
+                name === "#style" ||
+                (name === "style" &&
+                  node.nameText &&
+                  name === "style" &&
+                  ((_b = lookup.getTag(node.nameText)) == null
+                    ? void 0
+                    : _b.html))
+              ) {
+                getExtractor("css")
+                  .write(":root{")
+                  .copy({
+                    start: attr.value.value.start + 1,
+                    end: attr.value.value.end - 1,
+                  })
+                  .write("}");
               }
             }
           }
@@ -924,7 +968,7 @@ function extractStyle(opts) {
   function getExtractor(ext) {
     let extractor = extractorsByExt.get(ext);
     if (!extractor) {
-      extractorsByExt.set(ext, extractor = new Extractor(parsed));
+      extractorsByExt.set(ext, (extractor = new Extractor(parsed)));
     }
     return extractor;
   }
@@ -935,11 +979,7 @@ var import_relative_import_path = require("relative-import-path");
 
 // src/extractors/script/util/script-parser.ts
 var import_parser4 = require("@babel/parser");
-var plugins = [
-  "exportDefaultFrom",
-  "importAssertions",
-  "typescript"
-];
+var plugins = ["exportDefaultFrom", "importAssertions", "typescript"];
 var ScriptParser = class {
   #sourceFileName;
   #whitespace;
@@ -949,34 +989,40 @@ var ScriptParser = class {
   }
   statementAt(offset, src) {
     try {
-      return (0, import_parser4.parse)(this.#whitespace.slice(0, offset) + src, {
-        plugins,
-        strictMode: true,
-        errorRecovery: true,
-        sourceType: "module",
-        allowUndeclaredExports: true,
-        allowSuperOutsideMethod: true,
-        allowAwaitOutsideFunction: true,
-        allowReturnOutsideFunction: true,
-        sourceFilename: this.#sourceFileName
-      }).program.body;
+      return (0, import_parser4.parse)(
+        this.#whitespace.slice(0, offset) + src,
+        {
+          plugins,
+          strictMode: true,
+          errorRecovery: true,
+          sourceType: "module",
+          allowUndeclaredExports: true,
+          allowSuperOutsideMethod: true,
+          allowAwaitOutsideFunction: true,
+          allowReturnOutsideFunction: true,
+          sourceFilename: this.#sourceFileName,
+        }
+      ).program.body;
     } catch {
       return [];
     }
   }
   expressionAt(offset, src) {
     try {
-      return (0, import_parser4.parseExpression)(this.#whitespace.slice(0, offset) + src, {
-        plugins,
-        strictMode: true,
-        errorRecovery: true,
-        sourceType: "module",
-        allowUndeclaredExports: true,
-        allowSuperOutsideMethod: true,
-        allowAwaitOutsideFunction: true,
-        allowReturnOutsideFunction: true,
-        sourceFilename: this.#sourceFileName
-      });
+      return (0, import_parser4.parseExpression)(
+        this.#whitespace.slice(0, offset) + src,
+        {
+          plugins,
+          strictMode: true,
+          errorRecovery: true,
+          sourceType: "module",
+          allowUndeclaredExports: true,
+          allowSuperOutsideMethod: true,
+          allowAwaitOutsideFunction: true,
+          allowReturnOutsideFunction: true,
+          sourceFilename: this.#sourceFileName,
+        }
+      );
     } catch {
       return;
     }
@@ -986,7 +1032,14 @@ var ScriptParser = class {
 // src/extractors/script/util/is-valid-identifier.ts
 var import_helper_validator_identifier = require("@babel/helper-validator-identifier");
 function isValidIdentifier(name) {
-  return (0, import_helper_validator_identifier.isIdentifierName)(name) && !(0, import_helper_validator_identifier.isKeyword)(name) && !(0, import_helper_validator_identifier.isStrictBindReservedWord)(name, true);
+  return (
+    (0, import_helper_validator_identifier.isIdentifierName)(name) &&
+    !(0, import_helper_validator_identifier.isKeyword)(name) &&
+    !(0, import_helper_validator_identifier.isStrictBindReservedWord)(
+      name,
+      true
+    )
+  );
 }
 
 // src/extractors/script/util/attach-scopes.ts
@@ -1003,7 +1056,7 @@ function crawlProgramScope(parsed, scriptParser) {
   const programScope = {
     parent: void 0,
     hoists: false,
-    bindings: {}
+    bindings: {},
   };
   programScope.bindings.input = {
     type: 0 /* var */,
@@ -1013,7 +1066,7 @@ function crawlProgramScope(parsed, scriptParser) {
     hoisted: false,
     mutated: false,
     sourceName: void 0,
-    objectPath: void 0
+    objectPath: void 0,
   };
   visit(program.body, programScope);
   Scopes.set(program.body, programScope);
@@ -1022,7 +1075,8 @@ function crawlProgramScope(parsed, scriptParser) {
     const parentScope = scope.parent;
     let curParent = parentScope;
     while (curParent) {
-      const parentBinding = (_a = curParent.bindings) == null ? void 0 : _a[name];
+      const parentBinding =
+        (_a = curParent.bindings) == null ? void 0 : _a[name];
       if (parentBinding) {
         if (parentBinding.type === 2 /* hoisted */) {
           binding.hoisted = true;
@@ -1036,7 +1090,7 @@ function crawlProgramScope(parsed, scriptParser) {
           type: 2 /* hoisted */,
           scope: programScope,
           bindings: [binding],
-          hoisted: false
+          hoisted: false,
         };
         break;
       }
@@ -1066,7 +1120,10 @@ function crawlProgramScope(parsed, scriptParser) {
         case 16 /* AttrTag */: {
           if (child.var) {
             parentScope.bindings ??= {};
-            const parsedFn = scriptParser.expressionAt(child.var.value.start - 6, `${read(child.var.value)}=0`);
+            const parsedFn = scriptParser.expressionAt(
+              child.var.value.start - 6,
+              `${read(child.var.value)}=0`
+            );
             if (parsedFn) {
               const lVal = parsedFn.left;
               checkForMutations(parentScope, lVal);
@@ -1077,7 +1134,7 @@ function crawlProgramScope(parsed, scriptParser) {
                 ATTR_UNAMED
               )) {
                 const { name, objectPath, sourceName } = id;
-                const binding = parentScope.bindings[name] = {
+                const binding = (parentScope.bindings[name] = {
                   type: 0 /* var */,
                   name,
                   node: child,
@@ -1085,8 +1142,8 @@ function crawlProgramScope(parsed, scriptParser) {
                   hoisted: false,
                   mutated: false,
                   objectPath,
-                  sourceName
-                };
+                  sourceName,
+                });
                 potentialHoists.push(binding);
               }
             }
@@ -1095,7 +1152,7 @@ function crawlProgramScope(parsed, scriptParser) {
             const bodyScope = {
               parent: parentScope,
               hoists: false,
-              bindings: {}
+              bindings: {},
             };
             if (child.params) {
               bodyScope.bindings ??= {};
@@ -1112,7 +1169,7 @@ function crawlProgramScope(parsed, scriptParser) {
                       name,
                       node: child,
                       scope: bodyScope,
-                      hoisted: false
+                      hoisted: false,
                     };
                   }
                 }
@@ -1176,7 +1233,7 @@ function crawlProgramScope(parsed, scriptParser) {
                           attr.value.params.start - 2,
                           `{_${read({
                             start: attr.value.params.start,
-                            end: attr.value.body.end
+                            end: attr.value.body.end,
                           })}}`
                         )
                       );
@@ -1252,7 +1309,9 @@ function getMutatedVars(node) {
 function isMutatedVar(node, name) {
   const { bindings } = Scopes.get(node.body);
   const binding = bindings == null ? void 0 : bindings[name];
-  return (binding == null ? void 0 : binding.type) === 0 /* var */ && binding.mutated;
+  return (
+    (binding == null ? void 0 : binding.type) === 0 /* var */ && binding.mutated
+  );
 }
 function hasHoists(node) {
   return node.body ? Scopes.get(node.body).hoists : false;
@@ -1265,10 +1324,13 @@ function resolveWritableVar(scope, name) {
   let curScope = scope;
   do {
     const binding = (_a = curScope.bindings) == null ? void 0 : _a[name];
-    if ((binding == null ? void 0 : binding.type) === 0 /* var */ && binding.sourceName !== void 0) {
+    if (
+      (binding == null ? void 0 : binding.type) === 0 /* var */ &&
+      binding.sourceName !== void 0
+    ) {
       return binding;
     }
-  } while (curScope = curScope.parent);
+  } while ((curScope = curScope.parent));
 }
 function* getIdentifiers(lVal) {
   switch (lVal.type) {
@@ -1306,7 +1368,7 @@ function* getVarIdentifiers(parsed, lVal, objectPath, sourceName) {
       yield {
         name: lVal.name,
         objectPath,
-        sourceName
+        sourceName,
       };
       break;
     case "ObjectPattern":
@@ -1364,14 +1426,27 @@ function trackMutationsInClosures(root, scope, mutations) {
       case "ArrowFunctionExpression":
       case "ClassMethod":
       case "ClassPrivateMethod":
-        trackMutations(node, scope, mutations, node, /* @__PURE__ */ new Set(), []);
+        trackMutations(
+          node,
+          scope,
+          mutations,
+          node,
+          /* @__PURE__ */ new Set(),
+          []
+        );
         return true;
     }
   });
 }
-function trackMutations(node, scope, mutations, parentBlock, parentBlockShadows, parentBlockMutations) {
-  if (!node)
-    return;
+function trackMutations(
+  node,
+  scope,
+  mutations,
+  parentBlock,
+  parentBlockShadows,
+  parentBlockMutations
+) {
+  if (!node) return;
   let block = parentBlock;
   let blockShadows = parentBlockShadows;
   let blockMutations = parentBlockMutations;
@@ -1494,8 +1569,7 @@ function trackMutations(node, scope, mutations, parentBlock, parentBlockShadows,
   }
   if (block !== parentBlock && blockMutations.length) {
     for (const { name, start } of blockMutations) {
-      if (blockShadows.has(name))
-        continue;
+      if (blockShadows.has(name)) continue;
       const binding = resolveWritableVar(scope, name);
       if (binding) {
         binding.mutated = true;
@@ -1512,10 +1586,8 @@ function trackShadows(node, scope, shadows) {
   }
 }
 function traverse(node, enter) {
-  if (!node)
-    return;
-  if (enter(node))
-    return;
+  if (!node) return;
+  if (enter(node)) return;
   for (const key of t.VISITOR_KEYS[node.type]) {
     const child = node[key];
     if (Array.isArray(child)) {
@@ -1538,7 +1610,9 @@ function getComponentFilename(from) {
     nameNoExt = nameNoExt.slice(0, -2);
   }
   const isEntry = nameNoExt === "index";
-  const fileMatch = `(${nameNoExt.replace(/[.*+?^$[\]()|\\:!{}]/g, "\\$&")}\\.${isEntry ? "|" : ""})`;
+  const fileMatch = `(${nameNoExt.replace(/[.*+?^$[\]()|\\:!{}]/g, "\\$&")}\\.${
+    isEntry ? "|" : ""
+  })`;
   const componentMatch = new RegExp(
     `^${fileMatch}component(-browser)?\\.\\w+$`
   );
@@ -1559,19 +1633,21 @@ function tryReaddirSync(dir) {
 // src/extractors/script/util/runtime-overrides.ts
 var RuntimeOverloads = /* @__PURE__ */ new Map();
 var commentsReg = /\/\*(?:[^*]+|\*[^/])*\*\//gm;
-var replaceTokensReg = /\babstract\s+(\w+)|Marko\.(TemplateInput(?:<[^>]+>)?|Component)/gm;
-var overrideBlockReg = /\/\*[*\s]*@marko-overload-start[*\s]*\*\/([\s\S]+)\/\*[*\s]*@marko-overload-end[*\s]*\*\//g;
+var replaceTokensReg =
+  /\babstract\s+(\w+)|Marko\.(TemplateInput(?:<[^>]+>)?|Component)/gm;
+var overrideBlockReg =
+  /\/\*[*\s]*@marko-overload-start[*\s]*\*\/([\s\S]+)\/\*[*\s]*@marko-overload-end[*\s]*\*\//g;
 function getRuntimeOverrides(runtimeTypes, generics, applyGenerics) {
   let overloads = RuntimeOverloads.get(runtimeTypes);
   if (!overloads) {
     const match = overrideBlockReg.exec(runtimeTypes);
-    RuntimeOverloads.set(runtimeTypes, overloads = []);
+    RuntimeOverloads.set(runtimeTypes, (overloads = []));
     if (match) {
       let [, content] = match;
       let replaceMatch;
       let lastIndex = 0;
       content = content.replace(commentsReg, "");
-      while (replaceMatch = replaceTokensReg.exec(content)) {
+      while ((replaceMatch = replaceTokensReg.exec(content))) {
         const [, methodName, propertyName] = replaceMatch;
         const curText = content.slice(lastIndex, replaceMatch.index);
         lastIndex = replaceTokensReg.lastIndex;
@@ -1613,8 +1689,7 @@ function getRuntimeOverrides(runtimeTypes, generics, applyGenerics) {
 var MaybeInputTypedefReg = /@typedef\b[\s\S]*\bInput\b/;
 function getJSDocInputType(comment, ts) {
   var _a, _b, _c, _d;
-  if (!MaybeInputTypedefReg.test(comment))
-    return;
+  if (!MaybeInputTypedefReg.test(comment)) return;
   const sourceFile = ts.createSourceFile(
     "_.js",
     comment,
@@ -1622,18 +1697,23 @@ function getJSDocInputType(comment, ts) {
     false,
     ts.ScriptKind.JS
   );
-  const tags = (_b = (_a = sourceFile.endOfFileToken.jsDoc) == null ? void 0 : _a[0]) == null ? void 0 : _b.tags;
-  if (!(tags && hasInputTypeDef(ts, sourceFile, tags)))
-    return;
+  const tags =
+    (_b = (_a = sourceFile.endOfFileToken.jsDoc) == null ? void 0 : _a[0]) ==
+    null
+      ? void 0
+      : _b.tags;
+  if (!(tags && hasInputTypeDef(ts, sourceFile, tags))) return;
   let typeParameters;
   for (const tag of tags) {
     if (isTemplateTag(ts, tag)) {
-      let constraint = (_c = tag.constraint) == null ? void 0 : _c.type.getText(sourceFile);
+      let constraint =
+        (_c = tag.constraint) == null ? void 0 : _c.type.getText(sourceFile);
       for (const param of tag.typeParameters) {
         const value = {
           name: "" + param.name.escapedText,
           constraint,
-          default: (_d = param.default) == null ? void 0 : _d.getText(sourceFile)
+          default:
+            (_d = param.default) == null ? void 0 : _d.getText(sourceFile),
         };
         constraint = void 0;
         if (typeParameters) {
@@ -1649,7 +1729,11 @@ function getJSDocInputType(comment, ts) {
 function hasInputTypeDef(ts, sourceFile, tags) {
   var _a;
   for (const tag of tags) {
-    if (isTypeDefTag(ts, tag) && ((_a = tag.fullName) == null ? void 0 : _a.getText(sourceFile)) === "Input") {
+    if (
+      isTypeDefTag(ts, tag) &&
+      ((_a = tag.fullName) == null ? void 0 : _a.getText(sourceFile)) ===
+        "Input"
+    ) {
       return true;
     }
   }
@@ -1673,7 +1757,8 @@ var ATTR_UNAMED2 = "value";
 var REG_EXT = /(?<=[/\\][^/\\]+)\.[^.]+$/;
 var REG_BLOCK = /\s*{/y;
 var REG_NEW_LINE = /^|(\r?\n)/g;
-var REG_ATTR_ARG_LITERAL = /(?<=\s*)(["'])((?:[^"'\\]+|\\.|(?!\1))*)\1\s*([,)])/my;
+var REG_ATTR_ARG_LITERAL =
+  /(?<=\s*)(["'])((?:[^"'\\]+|\\.|(?!\1))*)\1\s*([,)])/my;
 var REG_TAG_IMPORT = /(?<=(['"]))<([^\1>]+)>(?=\1)/;
 var REG_INPUT_TYPE = /\s*(interface|type)\s+Input\b/y;
 var REG_OBJECT_PROPERTY = /^[_$a-z][_$a-z0-9]*$/i;
@@ -1732,7 +1817,7 @@ var ScriptExtractor = class {
           this.#writeComments(node);
           componentClassBody = {
             start: node.start + "class".length,
-            end: node.end
+            end: node.end,
           };
           break;
         case 25 /* Export */: {
@@ -1752,13 +1837,17 @@ var ScriptExtractor = class {
             if (templatePath) {
               const [{ length }] = tagImportMatch;
               const fromStart = node.start + tagImportMatch.index;
-              this.#extractor.copy({
-                start: node.start,
-                end: fromStart
-              }).write(templatePath).copy({
-                start: fromStart + length,
-                end: node.end
-              }).write("\n");
+              this.#extractor
+                .copy({
+                  start: node.start,
+                  end: fromStart,
+                })
+                .write(templatePath)
+                .copy({
+                  start: fromStart + length,
+                  end: node.end,
+                })
+                .write("\n");
               break;
             }
           }
@@ -1781,13 +1870,18 @@ var ScriptExtractor = class {
     let typeParamsStr = "";
     let typeArgsStr = "";
     let jsDocTemplateTagsStr = "";
-    const isExternalComponentFile = !componentClassBody && componentFileName !== void 0;
+    const isExternalComponentFile =
+      !componentClassBody && componentFileName !== void 0;
     if (inputType) {
       if (inputType.typeParameters) {
         let sep = SEP_EMPTY;
         typeParamsStr = typeArgsStr = "<";
         for (const param of inputType.typeParameters) {
-          typeParamsStr += sep + param.name + (param.constraint ? ` extends ${param.constraint}` : "") + (param.default ? ` = ${param.default}` : "");
+          typeParamsStr +=
+            sep +
+            param.name +
+            (param.constraint ? ` extends ${param.constraint}` : "") +
+            (param.default ? ` = ${param.default}` : "");
           typeArgsStr += sep + param.name;
           sep = SEP_COMMA_SPACE;
         }
@@ -1796,19 +1890,31 @@ var ScriptExtractor = class {
         if (this.#scriptLang === "js" /* js */) {
           for (const param of inputType.typeParameters) {
             jsDocTemplateTagsStr += `
-* @template ${param.constraint ? `{${removeNewLines(param.constraint)}} ` : ""}${param.default ? `[${param.name} = ${removeNewLines(param.default)}]` : param.name}`;
+* @template ${
+              param.constraint ? `{${removeNewLines(param.constraint)}} ` : ""
+            }${
+              param.default
+                ? `[${param.name} = ${removeNewLines(param.default)}]`
+                : param.name
+            }`;
           }
         }
       }
     } else {
       if (this.#scriptLang === "ts" /* ts */) {
         this.#extractor.write(
-          isExternalComponentFile ? "export type Input = Component['input'];\n" : `export interface Input {}
+          isExternalComponentFile
+            ? "export type Input = Component['input'];\n"
+            : `export interface Input {}
 `
         );
       } else {
         this.#extractor.write(
-          `/** @typedef {${isExternalComponentFile ? "Component['input']" : "Record<string, unknown>"}} Input */
+          `/** @typedef {${
+            isExternalComponentFile
+              ? "Component['input']"
+              : "Record<string, unknown>"
+          }} Input */
 `
         );
       }
@@ -1817,14 +1923,20 @@ var ScriptExtractor = class {
       if (this.#scriptLang === "ts" /* ts */) {
         this.#extractor.write(
           `import type Component from "${stripExt(
-            (0, import_relative_import_path.relativeImportPath)(this.#filename, componentFileName)
+            (0, import_relative_import_path.relativeImportPath)(
+              this.#filename,
+              componentFileName
+            )
           )}";
 `
         );
       } else {
         this.#extractor.write(
           `/** @typedef {import("${stripExt(
-            (0, import_relative_import_path.relativeImportPath)(this.#filename, componentFileName)
+            (0, import_relative_import_path.relativeImportPath)(
+              this.#filename,
+              componentFileName
+            )
           )}") extends infer Component ? Component extends { default: infer Component } ? Component : Component : never} Component */
 `
         );
@@ -1832,16 +1944,22 @@ var ScriptExtractor = class {
     } else {
       const body2 = componentClassBody || " {}";
       if (this.#scriptLang === "ts" /* ts */) {
-        this.#extractor.write(
-          `abstract class Component${typeParamsStr} extends Marko.Component<Input${typeArgsStr}>`
-        ).copy(body2).write("\nexport { type Component }\n");
+        this.#extractor
+          .write(
+            `abstract class Component${typeParamsStr} extends Marko.Component<Input${typeArgsStr}>`
+          )
+          .copy(body2)
+          .write("\nexport { type Component }\n");
       } else {
         this.#extractor.write(`/**${jsDocTemplateTagsStr}
   * @extends {Marko.Component<Input${typeArgsStr}>}
   * @abstract
   */
 `);
-        this.#extractor.write(`export class Component extends Marko.Component`).copy(body2).write("\n");
+        this.#extractor
+          .write(`export class Component extends Marko.Component`)
+          .copy(body2)
+          .write("\n");
       }
     }
     const didReturn = !!getReturnTag(program);
@@ -1861,7 +1979,9 @@ var ScriptExtractor = class {
 function ${templateName}() {
 `);
     }
-    this.#extractor.write(`  const input = ${this.#getCastedType(`Input${typeArgsStr}`)};
+    this.#extractor.write(`  const input = ${this.#getCastedType(
+      `Input${typeArgsStr}`
+    )};
   const component = ${this.#getCastedType(`Component${typeArgsStr}`)};
   const state = ${varShared("state")}(component);
   const $signal = ${this.#getCastedType("AbortSignal")};
@@ -1903,14 +2023,28 @@ function ${templateName}() {
       "Relate"
     )}<${internalInput}, Marko.Directives & Input${typeArgsStr}>) => (${varShared(
       "ReturnWithScope"
-    )}<${internalInput}, ${didReturn ? `typeof ${templateName + typeArgsStr} extends () => infer Return ? Return : never` : "void"}>)`;
-    const templateOverrideClass = `${templateBaseClass}<{${this.#runtimeTypes ? getRuntimeOverrides(this.#runtimeTypes, typeParamsStr, typeArgsStr) : ""}
-  _${typeParamsStr ? `<${internalApply} = 1>(): ${internalApply} extends 0
+    )}<${internalInput}, ${
+      didReturn
+        ? `typeof ${
+            templateName + typeArgsStr
+          } extends () => infer Return ? Return : never`
+        : "void"
+    }>)`;
+    const templateOverrideClass = `${templateBaseClass}<{${
+      this.#runtimeTypes
+        ? getRuntimeOverrides(this.#runtimeTypes, typeParamsStr, typeArgsStr)
+        : ""
+    }
+  _${
+    typeParamsStr
+      ? `<${internalApply} = 1>(): ${internalApply} extends 0
     ? ${typeParamsStr}() => <${internalInputWithExtends}>${renderAndReturn}
     : () => <${internalInputWithExtends}, ${typeParamsStr.slice(
-      1,
-      -1
-    )}>${renderAndReturn};` : `(): () => <${internalInputWithExtends}>${renderAndReturn};`}
+          1,
+          -1
+        )}>${renderAndReturn};`
+      : `(): () => <${internalInputWithExtends}>${renderAndReturn};`
+  }
 }>`;
     this.#extractor.copy(START_OF_FILE);
     if (this.#scriptLang === "ts" /* ts */) {
@@ -1930,7 +2064,11 @@ function ${templateName}() {
     this.#writeComments(program);
   }
   #writeCommentPragmas(program) {
-    const firstComments = program.static.length ? program.static[0].comments : program.body.length ? program.body[0].comments : program.comments;
+    const firstComments = program.static.length
+      ? program.static[0].comments
+      : program.body.length
+      ? program.body[0].comments
+      : program.comments;
     if (firstComments) {
       for (const comment of firstComments) {
         if (this.#testAtIndex(REG_COMMENT_PRAGMA, comment.start)) {
@@ -1992,8 +2130,7 @@ constructor(_?: Return) {}
               let renderId = this.#getRenderId(child);
               if (!renderId && alternates) {
                 for (const { node } of alternates) {
-                  if (renderId = this.#getRenderId(node))
-                    break;
+                  if ((renderId = this.#getRenderId(node))) break;
                 }
               }
               if (renderId) {
@@ -2005,9 +2142,16 @@ constructor(_?: Return) {}
                 );
               }
               this.#writeComments(child);
-              this.#extractor.write("if (").copy(
-                this.#getRangeWithoutTrailingComma((_a = child.args) == null ? void 0 : _a.value) || this.#getAttrValue(child, ATTR_UNAMED2) || "undefined"
-              ).write(") {\n");
+              this.#extractor
+                .write("if (")
+                .copy(
+                  this.#getRangeWithoutTrailingComma(
+                    (_a = child.args) == null ? void 0 : _a.value
+                  ) ||
+                    this.#getAttrValue(child, ATTR_UNAMED2) ||
+                    "undefined"
+                )
+                .write(") {\n");
               if (child.body) {
                 const localBindings = getHoistSources(child);
                 this.#writeChildren(child, child.body);
@@ -2022,7 +2166,10 @@ constructor(_?: Return) {}
                 for (const { node, condition } of alternates) {
                   this.#writeComments(node);
                   if (condition) {
-                    this.#extractor.write("\n} else if (\n").copy(condition).write("\n) {\n");
+                    this.#extractor
+                      .write("\n} else if (\n")
+                      .copy(condition)
+                      .write("\n) {\n");
                   } else if (node.nameText === "else") {
                     needsAlternate = false;
                     this.#extractor.write("\n} else {\n");
@@ -2062,7 +2209,10 @@ constructor(_?: Return) {}
               this.#extractor.write(`${varShared("forTag")}({
 `);
               this.#writeAttrs(child);
-              this.#extractor.write(`["renderBody"/*`).copy(child.name).write(`*/]: (`);
+              this.#extractor
+                .write(`["renderBody"/*`)
+                .copy(child.name)
+                .write(`*/]: (`);
               this.#writeComments(child);
               this.#extractor.copy(child.typeParams).write("(\n");
               if (child.params) {
@@ -2075,7 +2225,9 @@ constructor(_?: Return) {}
               }
               this.#writeReturn(
                 void 0,
-                (body == null ? void 0 : body.renderBody) ? getHoistSources(child) : void 0
+                (body == null ? void 0 : body.renderBody)
+                  ? getHoistSources(child)
+                  : void 0
               );
               this.#extractor.write("})");
               if (renderId) {
@@ -2087,9 +2239,14 @@ constructor(_?: Return) {}
             }
             case "while": {
               this.#writeComments(child);
-              this.#extractor.write("while (\n").copy(
-                this.#getRangeWithoutTrailingComma((_b = child.args) == null ? void 0 : _b.value) || "undefined"
-              ).write("\n) {\n");
+              this.#extractor
+                .write("while (\n")
+                .copy(
+                  this.#getRangeWithoutTrailingComma(
+                    (_b = child.args) == null ? void 0 : _b.value
+                  ) || "undefined"
+                )
+                .write("\n) {\n");
               const body = this.#processBody(child);
               if (body == null ? void 0 : body.renderBody) {
                 this.#writeChildren(child, body.renderBody);
@@ -2127,8 +2284,15 @@ constructor(_?: Return) {}
 `);
         for (const binding of mutatedVars) {
           this.#extractor.write(
-            `${// TODO use a different format to avoid const annotation.
-            this.#scriptLang === "js" /* js */ ? "/** @type {const} */" : ""}[${JSON.stringify(binding.name) + (binding.sourceName && binding.sourceName !== binding.name ? `, ${JSON.stringify(binding.sourceName)}` : "")}, ${varShared("rendered")}.returns[${this.#getRenderId(
+            `${
+              // TODO use a different format to avoid const annotation.
+              this.#scriptLang === "js" /* js */ ? "/** @type {const} */" : ""
+            }[${
+              JSON.stringify(binding.name) +
+              (binding.sourceName && binding.sourceName !== binding.name
+                ? `, ${JSON.stringify(binding.sourceName)}`
+                : "")
+            }, ${varShared("rendered")}.returns[${this.#getRenderId(
               binding.node
             )}]${binding.objectPath || ""}]${SEP_COMMA_NEW_LINE}`
           );
@@ -2154,29 +2318,40 @@ constructor(_?: Return) {}
     const renderId = this.#getRenderId(tag);
     if (renderId) {
       this.#extractor.write(
-        `${varShared("assertRendered")}(${varShared(
-          "rendered"
-        )}, ${renderId}, `
+        `${varShared("assertRendered")}(${varShared("rendered")}, ${renderId}, `
       );
     }
     if (tagName) {
       const def = this.#lookup.getTag(tagName);
       if (def) {
         const importPath = resolveTagImport(this.#filename, def);
-        const renderer = (importPath == null ? void 0 : importPath.endsWith(".marko")) ? `renderTemplate(import("${importPath}"))` : def.html ? `renderNativeTag("${def.name}")` : "missingTag";
+        const renderer = (
+          importPath == null ? void 0 : importPath.endsWith(".marko")
+        )
+          ? `renderTemplate(import("${importPath}"))`
+          : def.html
+          ? `renderNativeTag("${def.name}")`
+          : "missingTag";
         if (!def.html && isValidIdentifier(tagName)) {
-          this.#extractor.write(
-            `${varShared("renderPreferLocal")}(
+          this.#extractor
+            .write(
+              `${varShared("renderPreferLocal")}(
 // @ts-expect-error We expect the compiler to error because we are checking if the tag is defined.
 (${varShared("error")}, `
-          ).copy(tag.name).write(`),
+            )
+            .copy(tag.name).write(`),
 ${varShared(renderer)})`);
         } else {
           this.#extractor.write(varShared(renderer));
         }
       } else if (isValidIdentifier(tagName)) {
-        this.#extractor.write(`${varShared("renderDynamicTag")}(
-`).copy(tag.name).write("\n)");
+        this.#extractor
+          .write(
+            `${varShared("renderDynamicTag")}(
+`
+          )
+          .copy(tag.name)
+          .write("\n)");
       } else {
         this.#extractor.write(`${varShared("missingTag")}`);
       }
@@ -2209,11 +2384,17 @@ ${varShared(renderer)})`);
     if (dynamicTagNameExpression) {
       this.#extractor.copy(dynamicTagNameExpression);
     } else {
-      this.#extractor.write(`${varShared("interpolated")}\``).copy(tag.name).write("`");
+      this.#extractor
+        .write(`${varShared("interpolated")}\``)
+        .copy(tag.name)
+        .write("`");
     }
   }
   #writeTagNameComment(tag) {
-    this.#extractor.write("/*").copy(this.#getDynamicTagExpression(tag) || tag.name).write("*/");
+    this.#extractor
+      .write("/*")
+      .copy(this.#getDynamicTagExpression(tag) || tag.name)
+      .write("*/");
   }
   #writePlaceholder(placeholder) {
     this.#writeComments(placeholder);
@@ -2228,10 +2409,13 @@ ${varShared(renderer)})`);
     let hasAttrs = false;
     if (tag.shorthandId) {
       hasAttrs = true;
-      this.#extractor.write(`id: ${varShared("interpolated")}\``).copy({
-        start: tag.shorthandId.start + 1,
-        end: tag.shorthandId.end
-      }).write("`" + SEP_COMMA_NEW_LINE);
+      this.#extractor
+        .write(`id: ${varShared("interpolated")}\``)
+        .copy({
+          start: tag.shorthandId.start + 1,
+          end: tag.shorthandId.end,
+        })
+        .write("`" + SEP_COMMA_NEW_LINE);
     }
     if (tag.shorthandClassNames) {
       let sep = SEP_EMPTY;
@@ -2240,7 +2424,7 @@ ${varShared(renderer)})`);
       for (const shorthandClassName of tag.shorthandClassNames) {
         this.#extractor.write(sep).copy({
           start: shorthandClassName.start + 1,
-          end: shorthandClassName.end
+          end: shorthandClassName.end,
         });
         sep = SEP_SPACE;
       }
@@ -2249,7 +2433,12 @@ ${varShared(renderer)})`);
     let attrWhitespaceStart = Math.max(
       tag.name.end,
       ((_a = tag.shorthandId) == null ? void 0 : _a.end) ?? -1,
-      ((_c = (_b = tag.shorthandClassNames) == null ? void 0 : _b[tag.shorthandClassNames.length - 1]) == null ? void 0 : _c.end) ?? -1,
+      ((_c =
+        (_b = tag.shorthandClassNames) == null
+          ? void 0
+          : _b[tag.shorthandClassNames.length - 1]) == null
+        ? void 0
+        : _c.end) ?? -1,
       ((_d = tag.var) == null ? void 0 : _d.end) ?? -1,
       ((_e = tag.args) == null ? void 0 : _e.end) ?? -1,
       ((_f = tag.params) == null ? void 0 : _f.end) ?? -1
@@ -2270,7 +2459,10 @@ ${varShared(renderer)})`);
           case 10 /* AttrNamed */: {
             const isDefault = isEmptyRange(attr.name);
             const value = attr.value;
-            const modifierIndex = !isDefault && (!value || value.type === 13 /* AttrValue */) && this.#getNamedAttrModifierIndex(attr);
+            const modifierIndex =
+              !isDefault &&
+              (!value || value.type === 13) /* AttrValue */ &&
+              this.#getNamedAttrModifierIndex(attr);
             const defaultMapPosition = isDefault ? attr.name : void 0;
             let name = isDefault ? ATTR_UNAMED2 : attr.name;
             if (modifierIndex !== false) {
@@ -2279,40 +2471,85 @@ ${varShared(renderer)})`);
             if (value) {
               switch (value.type) {
                 case 14 /* AttrMethod */:
-                  this.#extractor.write('"').copy(defaultMapPosition).copy(name).write('"').copy(value.typeParams);
+                  this.#extractor
+                    .write('"')
+                    .copy(defaultMapPosition)
+                    .copy(name)
+                    .write('"')
+                    .copy(value.typeParams);
                   this.#copyWithMutationsReplaced(value.params);
                   this.#copyWithMutationsReplaced(value.body);
                   break;
                 case 13 /* AttrValue */:
-                  this.#extractor.write('"').copy(defaultMapPosition).copy(name).write('": (\n');
+                  this.#extractor
+                    .write('"')
+                    .copy(defaultMapPosition)
+                    .copy(name)
+                    .write('": (\n');
                   if (value.bound) {
-                    const memberExpressionStart = getBoundAttrMemberExpressionStartOffset(value);
+                    const memberExpressionStart =
+                      getBoundAttrMemberExpressionStartOffset(value);
                     if (memberExpressionStart === void 0) {
                       const valueLiteral = this.#read(value.value);
-                      this.#extractor.copy(value.value).write(`
-)${SEP_COMMA_NEW_LINE}"`).copy(defaultMapPosition).copy(name).write(
-                        `Change"(_${valueLiteral}) {
-${isMutatedVar(tag.parent, valueLiteral) ? `${varLocal("return")}.mutate.` : ""}`
-                      ).copy(value.value).write(`= _${valueLiteral};
+                      this.#extractor
+                        .copy(value.value)
+                        .write(
+                          `
+)${SEP_COMMA_NEW_LINE}"`
+                        )
+                        .copy(defaultMapPosition)
+                        .copy(name)
+                        .write(
+                          `Change"(_${valueLiteral}) {
+${
+  isMutatedVar(tag.parent, valueLiteral) ? `${varLocal("return")}.mutate.` : ""
+}`
+                        )
+                        .copy(value.value).write(`= _${valueLiteral};
 }`);
                     } else if (this.#code[memberExpressionStart] === "[") {
                       const memberObjectRange = {
                         start: value.value.start,
-                        end: memberExpressionStart + 1
+                        end: memberExpressionStart + 1,
                       };
                       const memberPropertyRange = {
                         start: memberObjectRange.end,
-                        end: value.value.end - 1
+                        end: value.value.end - 1,
                       };
                       const memberPropertyCloseRange = {
                         start: memberPropertyRange.end,
-                        end: value.value.end
+                        end: value.value.end,
                       };
-                      this.#extractor.copy(memberObjectRange).copy(memberPropertyRange).copy(memberPropertyCloseRange).write(`
-)${SEP_COMMA_NEW_LINE}"`).copy(defaultMapPosition).copy(name).write('Change": (\n').copy(memberObjectRange).write("\n`${\n").copy(memberPropertyRange).write("\n}Change`\n").copy(memberPropertyCloseRange).write("\n)");
+                      this.#extractor
+                        .copy(memberObjectRange)
+                        .copy(memberPropertyRange)
+                        .copy(memberPropertyCloseRange)
+                        .write(
+                          `
+)${SEP_COMMA_NEW_LINE}"`
+                        )
+                        .copy(defaultMapPosition)
+                        .copy(name)
+                        .write('Change": (\n')
+                        .copy(memberObjectRange)
+                        .write("\n`${\n")
+                        .copy(memberPropertyRange)
+                        .write("\n}Change`\n")
+                        .copy(memberPropertyCloseRange)
+                        .write("\n)");
                     } else {
-                      this.#extractor.copy(value.value).write(`
-)${SEP_COMMA_NEW_LINE}"`).copy(defaultMapPosition).copy(name).write('Change"').write(": ").copy(value.value).write(`Change`);
+                      this.#extractor
+                        .copy(value.value)
+                        .write(
+                          `
+)${SEP_COMMA_NEW_LINE}"`
+                        )
+                        .copy(defaultMapPosition)
+                        .copy(name)
+                        .write('Change"')
+                        .write(": ")
+                        .copy(value.value)
+                        .write(`Change`);
                     }
                   } else {
                     this.#copyWithMutationsReplaced(value.value);
@@ -2322,7 +2559,10 @@ ${isMutatedVar(tag.parent, valueLiteral) ? `${varLocal("return")}.mutate.` : ""}
               }
             } else if (attr.args) {
               this.#extractor.write('"').copy(name).write('": ');
-              if (typeof name !== "string" && this.#read(name).startsWith("on")) {
+              if (
+                typeof name !== "string" &&
+                this.#read(name).startsWith("on")
+              ) {
                 const stringLiteralFirstArgMatch = this.#execAtIndex(
                   REG_ATTR_ARG_LITERAL,
                   attr.args.value.start
@@ -2338,29 +2578,46 @@ ${isMutatedVar(tag.parent, valueLiteral) ? `${varLocal("return")}.mutate.` : ""}
                     const propertNameStart = stringLiteralStart + 1;
                     this.#extractor.write("component.").copy({
                       start: propertNameStart,
-                      end: propertNameStart + stringLiteralValue.length
+                      end: propertNameStart + stringLiteralValue.length,
                     });
                   } else {
-                    this.#extractor.write(`component[`).copy({
-                      start: stringLiteralStart,
-                      end: stringLiteralStart + stringLiteralValue.length + 2
-                    }).write("]");
+                    this.#extractor
+                      .write(`component[`)
+                      .copy({
+                        start: stringLiteralStart,
+                        end: stringLiteralStart + stringLiteralValue.length + 2,
+                      })
+                      .write("]");
                   }
                   if (hasPartialArgs) {
-                    this.#extractor.write(`.bind(component, `).copy({
-                      start: stringLiteralStart + stringLiteralFirstArgMatch[0].length,
-                      end: attr.args.value.end
-                    }).write(")");
+                    this.#extractor
+                      .write(`.bind(component, `)
+                      .copy({
+                        start:
+                          stringLiteralStart +
+                          stringLiteralFirstArgMatch[0].length,
+                        end: attr.args.value.end,
+                      })
+                      .write(")");
                   }
                 } else {
-                  this.#extractor.write(`${varShared("bind")}(component, 
-`).copy(attr.args.value).write("\n)");
+                  this.#extractor
+                    .write(
+                      `${varShared("bind")}(component, 
+`
+                    )
+                    .copy(attr.args.value)
+                    .write("\n)");
                 }
               } else {
                 this.#extractor.copy(attr.args);
               }
             } else {
-              this.#extractor.write('"').copy(defaultMapPosition).copy(name).write(`": ${modifierIndex === false ? "true" : '""'}`);
+              this.#extractor
+                .write('"')
+                .copy(defaultMapPosition)
+                .copy(name)
+                .write(`": ${modifierIndex === false ? "true" : '""'}`);
             }
             break;
           }
@@ -2370,7 +2627,14 @@ ${isMutatedVar(tag.parent, valueLiteral) ? `${varLocal("return")}.mutate.` : ""}
     }
     this.#copyWhitespaceWithin(
       attrWhitespaceStart,
-      tag.open.end - (tag.concise ? this.#code[tag.open.end] === ";" ? 1 : 0 : tag.selfClosed ? 2 : 1)
+      tag.open.end -
+        (tag.concise
+          ? this.#code[tag.open.end] === ";"
+            ? 1
+            : 0
+          : tag.selfClosed
+          ? 2
+          : 1)
     );
     return hasAttrs;
   }
@@ -2396,18 +2660,14 @@ ${isMutatedVar(tag.parent, valueLiteral) ? `${varLocal("return")}.mutate.` : ""}
     }
     if (dynamicAttrTagParents) {
       this.#writeDynamicAttrTagParents(dynamicAttrTagParents);
-      if (wasMerge)
-        this.#extractor.write(`)${SEP_COMMA_NEW_LINE}`);
+      if (wasMerge) this.#extractor.write(`)${SEP_COMMA_NEW_LINE}`);
     }
   }
   #writeStaticAttrTags(staticAttrTags, wasMerge) {
-    if (!wasMerge)
-      this.#extractor.write("...{");
+    if (!wasMerge) this.#extractor.write("...{");
     this.#extractor.write(
       `[${varShared("never")}](){
-const attrTags = ${varShared(
-        "attrTagNames"
-      )}(this);
+const attrTags = ${varShared("attrTagNames")}(this);
 `
     );
     for (const nameText in staticAttrTags) {
@@ -2418,15 +2678,21 @@ const attrTags = ${varShared(
       }
     }
     this.#extractor.write("\n}");
-    if (!wasMerge)
-      this.#extractor.write("}");
+    if (!wasMerge) this.#extractor.write("}");
     this.#extractor.write(SEP_COMMA_NEW_LINE);
     for (const nameText in staticAttrTags) {
       const attrTag = staticAttrTags[nameText];
       const attrTagDef = this.#lookup.getTag(nameText);
-      const isRepeated = attrTag.length > 1 ? true : attrTagDef == null ? void 0 : attrTagDef.isRepeated;
+      const isRepeated =
+        attrTag.length > 1
+          ? true
+          : attrTagDef == null
+          ? void 0
+          : attrTagDef.isRepeated;
       const [firstAttrTag] = attrTag;
-      const name = (attrTagDef == null ? void 0 : attrTagDef.targetProperty) || nameText.slice(nameText.lastIndexOf(":") + 1);
+      const name =
+        (attrTagDef == null ? void 0 : attrTagDef.targetProperty) ||
+        nameText.slice(nameText.lastIndexOf(":") + 1);
       this.#extractor.write(`["${name}"`);
       this.#writeTagNameComment(firstAttrTag);
       this.#extractor.write("]: ");
@@ -2449,9 +2715,16 @@ const attrTags = ${varShared(
         case "if": {
           const alternates = IF_TAG_ALTERNATES.get(tag);
           this.#writeComments(tag);
-          this.#extractor.write("((\n").copy(
-            this.#getRangeWithoutTrailingComma((_a = tag.args) == null ? void 0 : _a.value) || this.#getAttrValue(tag, ATTR_UNAMED2) || "undefined"
-          ).write("\n) ? ");
+          this.#extractor
+            .write("((\n")
+            .copy(
+              this.#getRangeWithoutTrailingComma(
+                (_a = tag.args) == null ? void 0 : _a.value
+              ) ||
+                this.#getAttrValue(tag, ATTR_UNAMED2) ||
+                "undefined"
+            )
+            .write("\n) ? ");
           this.#writeDynamicAttrTagBody(tag);
           let needsAlternate = true;
           if (alternates) {
@@ -2477,21 +2750,31 @@ const attrTags = ${varShared(
         case "for": {
           this.#extractor.write(`${varShared("forAttrTag")}({
 `);
-          if (!this.#writeAttrs(tag))
-            this.#writeTagNameComment(tag);
+          if (!this.#writeAttrs(tag)) this.#writeTagNameComment(tag);
           this.#extractor.write("}, \n");
           this.#writeComments(tag);
-          this.#extractor.copy(tag.typeParams).write("(\n").copy((_b = tag.params) == null ? void 0 : _b.value).write("\n) => (");
+          this.#extractor
+            .copy(tag.typeParams)
+            .write("(\n")
+            .copy((_b = tag.params) == null ? void 0 : _b.value)
+            .write("\n) => (");
           this.#writeDynamicAttrTagBody(tag);
           this.#extractor.write("))");
           break;
         }
         case "while": {
           this.#writeComments(tag);
-          this.#extractor.write(`${varShared("mergeAttrTags")}((
-`).copy(
-            this.#getRangeWithoutTrailingComma((_c = tag.args) == null ? void 0 : _c.value) || "undefined"
-          ).write("\n) ? [");
+          this.#extractor
+            .write(
+              `${varShared("mergeAttrTags")}((
+`
+            )
+            .copy(
+              this.#getRangeWithoutTrailingComma(
+                (_c = tag.args) == null ? void 0 : _c.value
+              ) || "undefined"
+            )
+            .write("\n) ? [");
           this.#writeDynamicAttrTagBody(tag);
           this.#extractor.write("] : [])");
           break;
@@ -2501,19 +2784,26 @@ const attrTags = ${varShared(
     }
   }
   #writeTagInputObject(tag) {
-    if (!tag.params)
-      this.#writeComments(tag);
+    if (!tag.params) this.#writeComments(tag);
     let hasInput = false;
     this.#extractor.write("{\n");
     if (tag.args) {
       hasInput = true;
-      this.#extractor.write("[").copy({
-        start: tag.args.start,
-        end: tag.args.start + 1
-      }).write('"value"').copy({
-        start: tag.args.end - 1,
-        end: tag.args.end
-      }).write(`]: ${varShared("tuple")}(`).copy(tag.args.value).write(")").write(",\n");
+      this.#extractor
+        .write("[")
+        .copy({
+          start: tag.args.start,
+          end: tag.args.start + 1,
+        })
+        .write('"value"')
+        .copy({
+          start: tag.args.end - 1,
+          end: tag.args.end,
+        })
+        .write(`]: ${varShared("tuple")}(`)
+        .copy(tag.args.value)
+        .write(")")
+        .write(",\n");
     }
     if (this.#writeAttrs(tag)) {
       hasInput = true;
@@ -2542,7 +2832,9 @@ const attrTags = ${varShared(
 `);
       }
       const localBindings = getHoistSources(tag);
-      const didReturn = (body == null ? void 0 : body.renderBody) && this.#writeChildren(tag, body.renderBody);
+      const didReturn =
+        (body == null ? void 0 : body.renderBody) &&
+        this.#writeChildren(tag, body.renderBody);
       if (!tag.params) {
         this.#extractor.write(`return () => {
 `);
@@ -2559,7 +2851,10 @@ const attrTags = ${varShared(
       this.#extractor.write(SEP_COMMA_NEW_LINE);
     }
     if (tag.type === 16 /* AttrTag */) {
-      this.#extractor.write("[/*").copy(tag.name).write(`*/Symbol.iterator]: ${varShared("any")}${SEP_COMMA_NEW_LINE}`);
+      this.#extractor
+        .write("[/*")
+        .copy(tag.name)
+        .write(`*/Symbol.iterator]: ${varShared("any")}${SEP_COMMA_NEW_LINE}`);
     }
     if (!hasInput) {
       this.#writeTagNameComment(tag);
@@ -2574,19 +2869,20 @@ const attrTags = ${varShared(
     this.#extractor.write("}");
   }
   #getCastedType(type) {
-    return this.#scriptLang === "ts" /* ts */ ? `${varShared("any")} as ${type}` : `/** @type {${type}} */(${varShared("any")})`;
+    return this.#scriptLang === "ts" /* ts */
+      ? `${varShared("any")} as ${type}`
+      : `/** @type {${type}} */(${varShared("any")})`;
   }
   #copyWithMutationsReplaced(range) {
     const mutations = this.#mutationOffsets;
-    if (!mutations)
-      return this.#extractor.copy(range);
+    if (!mutations) return this.#extractor.copy(range);
     const len = mutations.length;
     let curOffset = range.start;
     let minIndex = 0;
     do {
       let maxIndex = len;
       while (minIndex < maxIndex) {
-        const midIndex = minIndex + maxIndex >>> 1;
+        const midIndex = (minIndex + maxIndex) >>> 1;
         if (mutations[midIndex] >= curOffset) {
           maxIndex = midIndex;
         } else {
@@ -2597,7 +2893,7 @@ const attrTags = ${varShared(
       if (nextOffset >= range.end) {
         this.#extractor.copy({
           start: curOffset,
-          end: range.end
+          end: range.end,
         });
         return;
       }
@@ -2629,8 +2925,7 @@ const attrTags = ${varShared(
   #processBody(parent) {
     var _a;
     const { body } = parent;
-    if (!body)
-      return;
+    if (!body) return;
     const last = body.length - 1;
     let renderBody;
     let staticAttrTags;
@@ -2663,56 +2958,56 @@ const attrTags = ${varShared(
             case "if": {
               let alternates;
               hasDynamicAttrTags ||= child.hasAttrTags;
-              loop:
-                while (i <= last) {
-                  const nextChild = body[i++];
-                  switch (nextChild.type) {
-                    case 17 /* Text */:
-                      if (this.#isEmptyText(nextChild)) {
-                        continue loop;
-                      } else {
-                        break;
-                      }
-                    case 1 /* Tag */:
-                      switch (nextChild.nameText) {
-                        case "else-if": {
-                          const alternate = {
-                            condition: this.#getRangeWithoutTrailingComma(
+              loop: while (i <= last) {
+                const nextChild = body[i++];
+                switch (nextChild.type) {
+                  case 17 /* Text */:
+                    if (this.#isEmptyText(nextChild)) {
+                      continue loop;
+                    } else {
+                      break;
+                    }
+                  case 1 /* Tag */:
+                    switch (nextChild.nameText) {
+                      case "else-if": {
+                        const alternate = {
+                          condition:
+                            this.#getRangeWithoutTrailingComma(
                               (_a = nextChild.args) == null ? void 0 : _a.value
                             ) || this.#getAttrValue(nextChild, ATTR_UNAMED2),
-                            node: nextChild
-                          };
-                          hasDynamicAttrTags ||= nextChild.hasAttrTags;
-                          if (alternates) {
-                            alternates.push(alternate);
-                          } else {
-                            alternates = [alternate];
-                          }
-                          continue loop;
+                          node: nextChild,
+                        };
+                        hasDynamicAttrTags ||= nextChild.hasAttrTags;
+                        if (alternates) {
+                          alternates.push(alternate);
+                        } else {
+                          alternates = [alternate];
+                        }
+                        continue loop;
+                      }
+                      case "else": {
+                        const alternate = {
+                          condition: this.#getAttrValue(nextChild, "if"),
+                          node: nextChild,
+                        };
+                        hasDynamicAttrTags ||= nextChild.hasAttrTags;
+                        if (alternates) {
+                          alternates.push(alternate);
+                        } else {
+                          alternates = [alternate];
                         }
-                        case "else": {
-                          const alternate = {
-                            condition: this.#getAttrValue(nextChild, "if"),
-                            node: nextChild
-                          };
-                          hasDynamicAttrTags ||= nextChild.hasAttrTags;
-                          if (alternates) {
-                            alternates.push(alternate);
-                          } else {
-                            alternates = [alternate];
-                          }
-                          if (alternate.condition) {
-                            continue loop;
-                          } else {
-                            break loop;
-                          }
+                        if (alternate.condition) {
+                          continue loop;
+                        } else {
+                          break loop;
                         }
                       }
-                      break;
-                  }
-                  i--;
-                  break;
+                    }
+                    break;
                 }
+                i--;
+                break;
+              }
               IF_TAG_ALTERNATES.set(child, alternates);
             }
           }
@@ -2773,15 +3068,17 @@ const attrTags = ${varShared(
   #getAttrValue(tag, name) {
     if (tag.attrs) {
       for (const attr of tag.attrs) {
-        if (isValueAttribute(attr) && (this.#read(attr.name) || ATTR_UNAMED2) === name) {
+        if (
+          isValueAttribute(attr) &&
+          (this.#read(attr.name) || ATTR_UNAMED2) === name
+        ) {
           return attr.value.value;
         }
       }
     }
   }
   #getRangeWithoutTrailingComma(range) {
-    if (!range)
-      return void 0;
+    if (!range) return void 0;
     const { start } = range;
     let end = range.end - 1;
     while (end >= start) {
@@ -2806,7 +3103,9 @@ const attrTags = ${varShared(
     return true;
   }
   #getInputType(program) {
-    return this.#scriptLang === "ts" /* ts */ ? this.#getTSInputType(program) : this.#ts && this.#getJSDocInputType(program);
+    return this.#scriptLang === "ts" /* ts */
+      ? this.#getTSInputType(program)
+      : this.#ts && this.#getJSDocInputType(program);
   }
   #getTSInputType(program) {
     var _a;
@@ -2814,30 +3113,44 @@ const attrTags = ${varShared(
       if (node.type === 25 /* Export */) {
         const start = node.start + "export ".length;
         if (this.#testAtIndex(REG_INPUT_TYPE, start)) {
-          const [inputType] = this.#scriptParser.statementAt(start, this.#read({ start, end: node.end }));
+          const [inputType] = this.#scriptParser.statementAt(
+            start,
+            this.#read({ start, end: node.end })
+          );
           return {
-            typeParameters: (_a = inputType == null ? void 0 : inputType.typeParameters) == null ? void 0 : _a.params.map((param) => {
-              return {
-                name: param.name,
-                constraint: param.constraint ? this.#read(param.constraint) : void 0,
-                default: param.default ? this.#read(param.default) : void 0
-              };
-            })
+            typeParameters:
+              (_a = inputType == null ? void 0 : inputType.typeParameters) ==
+              null
+                ? void 0
+                : _a.params.map((param) => {
+                    return {
+                      name: param.name,
+                      constraint: param.constraint
+                        ? this.#read(param.constraint)
+                        : void 0,
+                      default: param.default
+                        ? this.#read(param.default)
+                        : void 0,
+                    };
+                  }),
           };
         }
       }
     }
   }
   #getJSDocInputType(program) {
-    return this.#getJSDocInputTypeFromNodes(program.static) || this.#getJSDocInputTypeFromNodes(program.body) || this.#getJSDocInputTypeFromNode(program);
+    return (
+      this.#getJSDocInputTypeFromNodes(program.static) ||
+      this.#getJSDocInputTypeFromNodes(program.body) ||
+      this.#getJSDocInputTypeFromNode(program)
+    );
   }
   #getJSDocInputTypeFromNodes(nodes) {
     for (const node of nodes) {
       const code = this.#read(node);
       code;
       const info = this.#getJSDocInputTypeFromNode(node);
-      if (info)
-        return info;
+      if (info) return info;
     }
   }
   #getJSDocInputTypeFromNode(node) {
@@ -2856,13 +3169,17 @@ const attrTags = ${varShared(
     }
   }
   #getDynamicTagExpression(tag) {
-    if (tag.name.expressions.length === 1 && isEmptyRange(tag.name.quasis[0]) && isEmptyRange(tag.name.quasis[1])) {
+    if (
+      tag.name.expressions.length === 1 &&
+      isEmptyRange(tag.name.quasis[0]) &&
+      isEmptyRange(tag.name.quasis[1])
+    ) {
       return tag.name.expressions[0].value;
     }
   }
   #getRenderId(tag) {
     let renderId = this.#renderIds.get(tag);
-    if (renderId === void 0 && tag.var || hasHoists(tag)) {
+    if ((renderId === void 0 && tag.var) || hasHoists(tag)) {
       renderId = this.#renderId++;
       this.#renderIds.set(tag, renderId);
     }
@@ -2872,8 +3189,7 @@ const attrTags = ${varShared(
     const start = attr.name.start + 1;
     const end = attr.name.end - 1;
     for (let i = end; i-- > start; ) {
-      if (this.#code.charAt(i) === ":")
-        return i;
+      if (this.#code.charAt(i) === ":") return i;
     }
     return false;
   }
@@ -2903,12 +3219,17 @@ function getReturnTag(parent) {
 }
 function isValueAttribute(attr) {
   var _a;
-  return attr.type === 10 /* AttrNamed */ && ((_a = attr.value) == null ? void 0 : _a.type) === 13 /* AttrValue */;
+  return (
+    attr.type === 10 /* AttrNamed */ &&
+    ((_a = attr.value) == null ? void 0 : _a.type) === 13 /* AttrValue */
+  );
 }
 function resolveTagImport(from, def) {
   const filename = resolveTagFile(def);
   if (filename) {
-    return from ? (0, import_relative_import_path.relativeImportPath)(from, filename) : filename;
+    return from
+      ? (0, import_relative_import_path.relativeImportPath)(from, filename)
+      : filename;
   }
 }
 function resolveTagFile(def) {
@@ -2938,15 +3259,14 @@ __export(project_exports, {
   getTagLookup: () => getTagLookup,
   getTypeLibs: () => getTypeLibs,
   setDefaultCompilerMeta: () => setDefaultCompilerMeta,
-  setDefaultTypePaths: () => setDefaultTypePaths
+  setDefaultTypePaths: () => setDefaultTypePaths,
 });
 var import_path2 = __toESM(require("path"));
 var import_module = require("module");
 var import_strip_json_comments = require("@luxass/strip-json-comments");
 var defaultTypeLibs = {};
 var defaultMeta;
-var ignoreErrors = (_err) => {
-};
+var ignoreErrors = (_err) => {};
 var metaByDir = /* @__PURE__ */ new Map();
 var metaByCompiler = /* @__PURE__ */ new Map();
 function getCompiler(dir) {
@@ -2965,54 +3285,66 @@ function getTypeLibs(rootDir, ts, host) {
   var _a;
   const config = getConfig(rootDir);
   let typeLibs = config.cache.get(getTypeLibs);
-  if (typeLibs)
-    return typeLibs;
+  if (typeLibs) return typeLibs;
   const resolveTypeCompilerOptions = {
-    moduleResolution: ts.ModuleResolutionKind.Bundler
+    moduleResolution: ts.ModuleResolutionKind.Bundler,
   };
   const markoRunGeneratedTypesFile = import_path2.default.join(
     rootDir,
     ".marko-run/routes.d.ts"
   );
   const resolveFromFile = import_path2.default.join(rootDir, "_.d.ts");
-  const internalTypesFile = defaultTypeLibs.internalTypesFile || ((_a = ts.resolveTypeReferenceDirective(
-    "@marko/language-tools/marko.internal.d.ts",
-    resolveFromFile,
-    resolveTypeCompilerOptions,
-    host
-  ).resolvedTypeReferenceDirective) == null ? void 0 : _a.resolvedFileName);
-  const { resolvedTypeReferenceDirective: resolvedMarkoTypes } = ts.resolveTypeReferenceDirective(
-    config.translator.runtimeTypes || "marko",
-    resolveFromFile,
-    resolveTypeCompilerOptions,
-    host
-  );
-  const { resolvedTypeReferenceDirective: resolvedMarkoRunTypes } = ts.resolveTypeReferenceDirective(
-    "@marko/run",
-    resolveFromFile,
-    resolveTypeCompilerOptions,
-    host
-  );
-  const markoTypesFile = (resolvedMarkoTypes == null ? void 0 : resolvedMarkoTypes.resolvedFileName) || defaultTypeLibs.markoTypesFile;
-  const markoRunTypesFile = resolvedMarkoRunTypes == null ? void 0 : resolvedMarkoRunTypes.resolvedFileName;
+  const internalTypesFile =
+    defaultTypeLibs.internalTypesFile ||
+    ((_a = ts.resolveTypeReferenceDirective(
+      "@marko/language-tools/marko.internal.d.ts",
+      resolveFromFile,
+      resolveTypeCompilerOptions,
+      host
+    ).resolvedTypeReferenceDirective) == null
+      ? void 0
+      : _a.resolvedFileName);
+  const { resolvedTypeReferenceDirective: resolvedMarkoTypes } =
+    ts.resolveTypeReferenceDirective(
+      config.translator.runtimeTypes || "marko",
+      resolveFromFile,
+      resolveTypeCompilerOptions,
+      host
+    );
+  const { resolvedTypeReferenceDirective: resolvedMarkoRunTypes } =
+    ts.resolveTypeReferenceDirective(
+      "@marko/run",
+      resolveFromFile,
+      resolveTypeCompilerOptions,
+      host
+    );
+  const markoTypesFile =
+    (resolvedMarkoTypes == null
+      ? void 0
+      : resolvedMarkoTypes.resolvedFileName) || defaultTypeLibs.markoTypesFile;
+  const markoRunTypesFile =
+    resolvedMarkoRunTypes == null
+      ? void 0
+      : resolvedMarkoRunTypes.resolvedFileName;
   if (!internalTypesFile || !markoTypesFile) {
     throw new Error("Could not resolve marko type files.");
   }
   config.cache.set(
     getTypeLibs,
-    typeLibs = {
+    (typeLibs = {
       internalTypesFile,
       markoTypesFile,
       markoTypesCode: host.readFile(markoTypesFile) || "",
       markoRunTypesFile,
-      markoRunGeneratedTypesFile: host.fileExists(markoRunGeneratedTypesFile) ? markoRunGeneratedTypesFile : void 0
-    }
+      markoRunGeneratedTypesFile: host.fileExists(markoRunGeneratedTypesFile)
+        ? markoRunGeneratedTypesFile
+        : void 0,
+    })
   );
   return typeLibs;
 }
 function getScriptLang(fileName, defaultScriptLang, ts, host) {
-  if (fileName.endsWith(".d.marko"))
-    return "ts" /* ts */;
+  if (fileName.endsWith(".d.marko")) return "ts" /* ts */;
   const dir = import_path2.default.dirname(fileName);
   const config = getConfig(dir);
   const cache = config.cache.get(getScriptLang);
@@ -3029,22 +3361,30 @@ function getScriptLang(fileName, defaultScriptLang, ts, host) {
         if (configSource) {
           const config2 = tryParseJSONWithComments(configSource);
           if (config2) {
-            const definedScriptLang = config2["script-lang"] || config2.scriptLang;
+            const definedScriptLang =
+              config2["script-lang"] || config2.scriptLang;
             if (definedScriptLang !== void 0) {
-              scriptLang = definedScriptLang === "ts" /* ts */ ? "ts" /* ts */ : "js" /* js */;
+              scriptLang =
+                definedScriptLang === "ts" /* ts */
+                  ? "ts" /* ts */
+                  : "js" /* js */;
             }
           }
         }
-      } catch {
-      }
+      } catch {}
     }
     if (scriptLang === void 0) {
-      scriptLang = /[/\\]node_modules[/\\]/.test(dir) ? "js" /* js */ : defaultScriptLang;
+      scriptLang = /[/\\]node_modules[/\\]/.test(dir)
+        ? "js" /* js */
+        : defaultScriptLang;
     }
     if (cache) {
       cache.set(dir, scriptLang);
     } else {
-      config.cache.set(getScriptLang, /* @__PURE__ */ new Map([[dir, scriptLang]]));
+      config.cache.set(
+        getScriptLang,
+        /* @__PURE__ */ new Map([[dir, scriptLang]])
+      );
     }
   }
   return scriptLang;
@@ -3070,8 +3410,8 @@ function setDefaultCompilerMeta(compiler, config) {
     config: {
       ...config,
       cache: /* @__PURE__ */ new Map(),
-      translator
-    }
+      translator,
+    },
   };
   compiler.configure(defaultMeta.config);
 }
@@ -3097,7 +3437,9 @@ function getMeta(dir) {
 function loadMeta(dir) {
   let cached = metaByDir.get(dir);
   if (!cached) {
-    const require2 = (0, import_module.createRequire)(import_path2.default.join(dir, "_.js"));
+    const require2 = (0, import_module.createRequire)(
+      import_path2.default.join(dir, "_.js")
+    );
     const configPath = require2.resolve("@marko/compiler/config");
     cached = metaByCompiler.get(configPath);
     if (!cached) {
@@ -3108,8 +3450,8 @@ function loadMeta(dir) {
         config: {
           ...config,
           cache: /* @__PURE__ */ new Map(),
-          translator: require2(config.translator)
-        }
+          translator: require2(config.translator),
+        },
       };
       compiler.configure(cached.config);
       metaByCompiler.set(configPath, cached);
@@ -3136,7 +3478,10 @@ function getTagLookupForProject(meta, dir) {
     if (cache) {
       cache.set(dir, lookup);
     } else {
-      meta.config.cache.set(getTagLookupForProject, /* @__PURE__ */ new Map([[dir, lookup]]));
+      meta.config.cache.set(
+        getTagLookupForProject,
+        /* @__PURE__ */ new Map([[dir, lookup]])
+      );
     }
   }
   return lookup;
@@ -3161,31 +3506,39 @@ var processors_exports = {};
 __export(processors_exports, {
   create: () => create,
   extensions: () => extensions,
-  has: () => has
+  has: () => has,
 });
 
 // src/util/get-ext.ts
 function getExt(fileName) {
   const extIndex = fileName.lastIndexOf(".");
-  if (extIndex !== -1)
-    return fileName.slice(extIndex);
+  if (extIndex !== -1) return fileName.slice(extIndex);
 }
 
 // src/processors/marko.ts
 var import_path3 = __toESM(require("path"));
 var isRemapExtensionReg = /\.ts$/;
-var skipRemapExtensionsReg = /\.(?:[cm]?jsx?|json|marko|css|less|sass|scss|styl|stylus|pcss|postcss|sss|a?png|jpe?g|jfif|pipeg|pjp|gif|svg|ico|web[pm]|avif|mp4|ogg|mp3|wav|flac|aac|opus|woff2?|eot|[ot]tf|webmanifest|pdf|txt)$/;
+var skipRemapExtensionsReg =
+  /\.(?:[cm]?jsx?|json|marko|css|less|sass|scss|styl|stylus|pcss|postcss|sss|a?png|jpe?g|jfif|pipeg|pjp|gif|svg|ico|web[pm]|avif|mp4|ogg|mp3|wav|flac|aac|opus|woff2?|eot|[ot]tf|webmanifest|pdf|txt)$/;
 var marko_default = {
   extension: ".marko",
   create({ ts, host, configFile }) {
-    const currentDirectory = host.getCurrentDirectory ? host.getCurrentDirectory() : ts.sys.getCurrentDirectory();
-    const defaultScriptLang = configFile && /tsconfig/g.test(configFile) ? "ts" /* ts */ : "js" /* js */;
+    const currentDirectory = host.getCurrentDirectory
+      ? host.getCurrentDirectory()
+      : ts.sys.getCurrentDirectory();
+    const defaultScriptLang =
+      configFile && /tsconfig/g.test(configFile)
+        ? "ts" /* ts */
+        : "js"; /* js */
     const runtimeTypes = getTypeLibs(currentDirectory, ts, host);
     const rootNames = [
       runtimeTypes.internalTypesFile,
-      runtimeTypes.markoTypesFile
+      runtimeTypes.markoTypesFile,
     ];
-    const getJSFileIfTSExists = (source, importer) => host.fileExists(import_path3.default.join(importer, "..", `${source}.ts`)) && `${source}.js`;
+    const getJSFileIfTSExists = (source, importer) =>
+      host.fileExists(
+        import_path3.default.join(importer, "..", `${source}.ts`)
+      ) && `${source}.js`;
     const compileConfig = {
       output: "source",
       stripTypes: true,
@@ -3203,26 +3556,34 @@ var marko_default = {
                 var _a;
                 const { node } = decl;
                 const value = (_a = node.source) == null ? void 0 : _a.value;
-                const importKind = "importKind" in node ? node.importKind : void 0;
-                if ((value == null ? void 0 : value[0]) === "." && (!importKind || importKind === "value") && !skipRemapExtensionsReg.test(value)) {
+                const importKind =
+                  "importKind" in node ? node.importKind : void 0;
+                if (
+                  (value == null ? void 0 : value[0]) === "." &&
+                  (!importKind || importKind === "value") &&
+                  !skipRemapExtensionsReg.test(value)
+                ) {
                   const filename = decl.hub.file.opts.filename;
-                  const remap = isRemapExtensionReg.test(value) ? `${value.slice(0, -2)}js` : getJSFileIfTSExists(value, filename) || getJSFileIfTSExists(`${value}/index`, filename);
+                  const remap = isRemapExtensionReg.test(value)
+                    ? `${value.slice(0, -2)}js`
+                    : getJSFileIfTSExists(value, filename) ||
+                      getJSFileIfTSExists(`${value}/index`, filename);
                   if (remap) {
                     node.source.value = remap;
                   }
                 }
-              }
-            }
-          }
+              },
+            },
+          },
         ],
         caller: {
           name: "@marko/type-check",
           supportsStaticESM: true,
           supportsDynamicImport: true,
           supportsTopLevelAwait: true,
-          supportsExportNamespaceFrom: true
-        }
-      }
+          supportsExportNamespaceFrom: true,
+        },
+      },
     };
     if (runtimeTypes.markoRunTypesFile) {
       rootNames.push(runtimeTypes.markoRunTypesFile);
@@ -3235,10 +3596,16 @@ var marko_default = {
         return rootNames;
       },
       getScriptExtension(fileName) {
-        return getScriptLang(fileName, defaultScriptLang, ts, host) === "ts" /* ts */ ? ts.Extension.Ts : ts.Extension.Js;
+        return getScriptLang(fileName, defaultScriptLang, ts, host) ===
+          "ts" /* ts */
+          ? ts.Extension.Ts
+          : ts.Extension.Js;
       },
       getScriptKind(fileName) {
-        return getScriptLang(fileName, defaultScriptLang, ts, host) === "ts" /* ts */ ? ts.ScriptKind.TS : ts.ScriptKind.JS;
+        return getScriptLang(fileName, defaultScriptLang, ts, host) ===
+          "ts" /* ts */
+          ? ts.ScriptKind.TS
+          : ts.ScriptKind.JS;
       },
       extract(fileName, code) {
         const dir = import_path3.default.dirname(fileName);
@@ -3247,13 +3614,8 @@ var marko_default = {
           ts,
           parsed,
           lookup: getTagLookup(dir),
-          scriptLang: getScriptLang(
-            fileName,
-            defaultScriptLang,
-            ts,
-            host
-          ),
-          runtimeTypesCode: runtimeTypes.markoTypesCode
+          scriptLang: getScriptLang(fileName, defaultScriptLang, ts, host),
+          runtimeTypesCode: runtimeTypes.markoTypesCode,
         });
       },
       print({ extracted: { parsed } }) {
@@ -3266,7 +3628,9 @@ var marko_default = {
         var _a, _b, _c;
         let code = "";
         const nlChar = formatSettings.newLineCharacter;
-        const tabChar = formatSettings.convertTabsToSpaces ? " ".repeat(formatSettings.indentSize) : "	";
+        const tabChar = formatSettings.convertTabsToSpaces
+          ? " ".repeat(formatSettings.indentSize)
+          : "	";
         let defaultExport;
         let defaultExportId;
         let componentImpl;
@@ -3274,23 +3638,35 @@ var marko_default = {
         for (const statement of sourceFile.statements) {
           if (ts.isExportAssignment(statement)) {
             defaultExport = statement;
-            defaultExportId = ts.isIdentifier(statement.expression) ? statement.expression.escapedText : void 0;
-          } else if (ts.isClassDeclaration(statement) && ((_a = statement.name) == null ? void 0 : _a.escapedText) === "Component") {
+            defaultExportId = ts.isIdentifier(statement.expression)
+              ? statement.expression.escapedText
+              : void 0;
+          } else if (
+            ts.isClassDeclaration(statement) &&
+            ((_a = statement.name) == null ? void 0 : _a.escapedText) ===
+              "Component"
+          ) {
             componentImpl = statement;
-          } else if (ts.isFunctionDeclaration(statement) && ((_b = statement.name) == null ? void 0 : _b.escapedText) === "___marko_internal_template") {
+          } else if (
+            ts.isFunctionDeclaration(statement) &&
+            ((_b = statement.name) == null ? void 0 : _b.escapedText) ===
+              "___marko_internal_template"
+          ) {
             internalRenderImpl = statement;
           }
         }
         for (const statement of sourceFile.statements) {
-          if (statement === defaultExport || // skips the generated `export default ...`.
-          statement === componentImpl || // skips the generated `class {}` since it needs special processing.
-          statement === internalRenderImpl || // skips the internal template render code.
-          isExportComponentType(statement) || // skips the generated `export { type Component }`.
-          isImportComponentType(statement) || // skips the generated `import type Component from "..."`.
-          isExportEmptyInputType(statement) || // skips empty exported Input, eg `export type Input = {}` or `export interface Input {}`.
-          isExportInputTypeAsComponentInput(statement) || // skips outputing `export type Input = Component["input"]` since it's inferred.
-          defaultExportId && // If the `export default` was an identifier, we also remove the variable that declared the identifier.
-          isVariableStatementForName(statement, defaultExportId)) {
+          if (
+            statement === defaultExport || // skips the generated `export default ...`.
+            statement === componentImpl || // skips the generated `class {}` since it needs special processing.
+            statement === internalRenderImpl || // skips the internal template render code.
+            isExportComponentType(statement) || // skips the generated `export { type Component }`.
+            isImportComponentType(statement) || // skips the generated `import type Component from "..."`.
+            isExportEmptyInputType(statement) || // skips empty exported Input, eg `export type Input = {}` or `export interface Input {}`.
+            isExportInputTypeAsComponentInput(statement) || // skips outputing `export type Input = Component["input"]` since it's inferred.
+            (defaultExportId && // If the `export default` was an identifier, we also remove the variable that declared the identifier.
+              isVariableStatementForName(statement, defaultExportId))
+          ) {
             continue;
           }
           const printed = printer.printNode(
@@ -3298,34 +3674,55 @@ var marko_default = {
             statement,
             sourceFile
           );
-          if (!/^(?:import|export) /.test(printed))
-            code += "static ";
+          if (!/^(?:import|export) /.test(printed)) code += "static ";
           code += printed + nlChar;
         }
         if (componentImpl == null ? void 0 : componentImpl.members.length) {
           code += `class {${nlChar}`;
           for (const member of componentImpl.members) {
             if (ts.isPropertyDeclaration(member)) {
-              code += `${tabChar}declare ${printer.printNode(ts.EmitHint.Unspecified, member, sourceFile) + nlChar}`;
-            } else if (ts.isMethodDeclaration(member) || ts.isGetAccessorDeclaration(member) || ts.isSetAccessorDeclaration(member)) {
-              code += `${tabChar + printer.printNode(ts.EmitHint.Unspecified, member, sourceFile).replace(/;\s*$/, "")} { return ${castType("any")}; }${nlChar}`;
+              code += `${tabChar}declare ${
+                printer.printNode(ts.EmitHint.Unspecified, member, sourceFile) +
+                nlChar
+              }`;
+            } else if (
+              ts.isMethodDeclaration(member) ||
+              ts.isGetAccessorDeclaration(member) ||
+              ts.isSetAccessorDeclaration(member)
+            ) {
+              code += `${
+                tabChar +
+                printer
+                  .printNode(ts.EmitHint.Unspecified, member, sourceFile)
+                  .replace(/;\s*$/, "")
+              } { return ${castType("any")}; }${nlChar}`;
             } else if (ts.isIndexSignatureDeclaration(member)) {
-              code += tabChar + printer.printNode(ts.EmitHint.Unspecified, member, sourceFile) + nlChar;
+              code +=
+                tabChar +
+                printer.printNode(ts.EmitHint.Unspecified, member, sourceFile) +
+                nlChar;
             }
           }
           code += `}${nlChar}`;
         }
         if (internalRenderImpl) {
-          const returnType = (_c = typeChecker.getSignatureFromDeclaration(internalRenderImpl)) == null ? void 0 : _c.getReturnType();
+          const returnType =
+            (_c =
+              typeChecker.getSignatureFromDeclaration(internalRenderImpl)) ==
+            null
+              ? void 0
+              : _c.getReturnType();
           if (returnType) {
             const props = returnType.getProperties();
-            const valueType = props.length === 1 && props[0].name === "value" && typeChecker.getPropertyOfType(returnType, "value") || void 0;
+            const valueType =
+              (props.length === 1 &&
+                props[0].name === "value" &&
+                typeChecker.getPropertyOfType(returnType, "value")) ||
+              void 0;
             code += "<return ";
             if (valueType) {
               code += `= ${castType(
-                typeChecker.typeToString(
-                  typeChecker.getTypeOfSymbol(valueType)
-                )
+                typeChecker.typeToString(typeChecker.getTypeOfSymbol(valueType))
               )}`;
             } else {
               code += `...${castType(typeChecker.typeToString(returnType))}`;
@@ -3334,20 +3731,52 @@ var marko_default = {
           }
         }
         return { code };
-      }
+      },
     };
     function isImportComponentType(statement) {
       var _a, _b;
-      return ts.isImportDeclaration(statement) && ((_b = (_a = statement.importClause) == null ? void 0 : _a.name) == null ? void 0 : _b.escapedText) === "Component";
+      return (
+        ts.isImportDeclaration(statement) &&
+        ((_b = (_a = statement.importClause) == null ? void 0 : _a.name) == null
+          ? void 0
+          : _b.escapedText) === "Component"
+      );
     }
     function isExportInputTypeAsComponentInput(statement) {
-      return ts.isTypeAliasDeclaration(statement) && statement.name.escapedText === "Input" && ts.isIndexedAccessTypeNode(statement.type) && ts.isTypeReferenceNode(statement.type.objectType) && ts.isIdentifier(statement.type.objectType.typeName) && statement.type.objectType.typeName.escapedText === "Component" && ts.isLiteralTypeNode(statement.type.indexType) && ts.isStringLiteral(statement.type.indexType.literal) && statement.type.indexType.literal.text === "input";
+      return (
+        ts.isTypeAliasDeclaration(statement) &&
+        statement.name.escapedText === "Input" &&
+        ts.isIndexedAccessTypeNode(statement.type) &&
+        ts.isTypeReferenceNode(statement.type.objectType) &&
+        ts.isIdentifier(statement.type.objectType.typeName) &&
+        statement.type.objectType.typeName.escapedText === "Component" &&
+        ts.isLiteralTypeNode(statement.type.indexType) &&
+        ts.isStringLiteral(statement.type.indexType.literal) &&
+        statement.type.indexType.literal.text === "input"
+      );
     }
     function isExportEmptyInputType(statement) {
-      return ts.isTypeAliasDeclaration(statement) && statement.name.escapedText === "Input" && ts.isTypeLiteralNode(statement.type) && !statement.typeParameters && statement.type.members.length === 0 || ts.isInterfaceDeclaration(statement) && statement.name.escapedText === "Input" && !statement.heritageClauses && !statement.typeParameters && statement.members.length === 0;
+      return (
+        (ts.isTypeAliasDeclaration(statement) &&
+          statement.name.escapedText === "Input" &&
+          ts.isTypeLiteralNode(statement.type) &&
+          !statement.typeParameters &&
+          statement.type.members.length === 0) ||
+        (ts.isInterfaceDeclaration(statement) &&
+          statement.name.escapedText === "Input" &&
+          !statement.heritageClauses &&
+          !statement.typeParameters &&
+          statement.members.length === 0)
+      );
     }
     function isExportComponentType(statement) {
-      return ts.isExportDeclaration(statement) && statement.exportClause && ts.isNamedExports(statement.exportClause) && statement.exportClause.elements.length === 1 && statement.exportClause.elements[0].name.escapedText === "Component";
+      return (
+        ts.isExportDeclaration(statement) &&
+        statement.exportClause &&
+        ts.isNamedExports(statement.exportClause) &&
+        statement.exportClause.elements.length === 1 &&
+        statement.exportClause.elements[0].name.escapedText === "Component"
+      );
     }
     function isVariableStatementForName(statement, name) {
       if (ts.isVariableStatement(statement)) {
@@ -3358,7 +3787,7 @@ var marko_default = {
         }
       }
     }
-  }
+  },
 };
 function castType(type) {
   if (type === "any") {
@@ -3371,7 +3800,7 @@ function castType(type) {
 var extensions = [marko_default.extension];
 function create(options) {
   return {
-    [marko_default.extension]: marko_default.create(options)
+    [marko_default.extension]: marko_default.create(options),
   };
 }
 function has(fileName) {
@@ -3385,13 +3814,13 @@ function isDefinitionFile(fileName) {
 }
 
 // src/extractors/html/keywords.ts
-var builtinTagsRegex = /^(?:a(?:(?:bbr|cronym|ddress|pplet|r(?:ea|ticle)|side|udio))?|b(?:(?:ase(?:font)?|d[io]|gsound|ig|l(?:ink|ockquote)|ody|r|utton))?|c(?:a(?:nvas|ption)|enter|ite|o(?:de|l(?:group)?|mmand|ntent))|d(?:ata(?:list)?|d|e(?:l|tails)|fn|i(?:alog|r|v)|l|t)|e(?:lement|m(?:bed)?)|f(?:i(?:eldset|g(?:caption|ure))|o(?:nt|oter|rm)|rame(?:set)?)|h(?:1|2|3|4|5|6|ead(?:er)?|group|r|tml)|i(?:(?:frame|m(?:age|g)|n(?:put|s)|sindex))?|k(?:bd|eygen)|l(?:abel|egend|i(?:(?:nk|sting))?)|m(?:a(?:in|p|r(?:k|quee)|th)|e(?:nu(?:item)?|t(?:a|er))|ulticol)|n(?:av|extid|o(?:br|embed|frames|script))|o(?:bject|l|pt(?:group|ion)|utput)|p(?:(?:aram|icture|laintext|r(?:e|ogress)))?|q|r(?:bc?|p|tc?|uby)|s(?:(?:amp|cript|e(?:ction|lect)|hadow|lot|mall|ource|pa(?:cer|n)|t(?:r(?:ike|ong)|yle)|u(?:b|mmary|p)|vg))?|t(?:able|body|d|e(?:mplate|xtarea)|foot|h(?:ead)?|i(?:me|tle)|r(?:ack)?|t)|ul?|v(?:ar|ideo)|wbr|xmp)$/;
+var builtinTagsRegex =
+  /^(?:a(?:(?:bbr|cronym|ddress|pplet|r(?:ea|ticle)|side|udio))?|b(?:(?:ase(?:font)?|d[io]|gsound|ig|l(?:ink|ockquote)|ody|r|utton))?|c(?:a(?:nvas|ption)|enter|ite|o(?:de|l(?:group)?|mmand|ntent))|d(?:ata(?:list)?|d|e(?:l|tails)|fn|i(?:alog|r|v)|l|t)|e(?:lement|m(?:bed)?)|f(?:i(?:eldset|g(?:caption|ure))|o(?:nt|oter|rm)|rame(?:set)?)|h(?:1|2|3|4|5|6|ead(?:er)?|group|r|tml)|i(?:(?:frame|m(?:age|g)|n(?:put|s)|sindex))?|k(?:bd|eygen)|l(?:abel|egend|i(?:(?:nk|sting))?)|m(?:a(?:in|p|r(?:k|quee)|th)|e(?:nu(?:item)?|t(?:a|er))|ulticol)|n(?:av|extid|o(?:br|embed|frames|script))|o(?:bject|l|pt(?:group|ion)|utput)|p(?:(?:aram|icture|laintext|r(?:e|ogress)))?|q|r(?:bc?|p|tc?|uby)|s(?:(?:amp|cript|e(?:ction|lect)|hadow|lot|mall|ource|pa(?:cer|n)|t(?:r(?:ike|ong)|yle)|u(?:b|mmary|p)|vg))?|t(?:able|body|d|e(?:mplate|xtarea)|foot|h(?:ead)?|i(?:me|tle)|r(?:ack)?|t)|ul?|v(?:ar|ideo)|wbr|xmp)$/;
 function isHTMLTag(tag) {
   return builtinTagsRegex.test(tag);
 }
 function getAttributeValueType(value) {
-  if (value === void 0 || value[0] !== "=")
-    return void 0;
+  if (value === void 0 || value[0] !== "=") return void 0;
   value = value.substring(1).trim();
   switch (value) {
     case "NaN":
@@ -3445,13 +3874,16 @@ var HTMLExtractor = class {
   }
   #visitNode(node) {
     var _a;
-    let hasDynamicBody = false, hasDynamicAttrs = false, isDynamic = false;
+    let hasDynamicBody = false,
+      hasDynamicAttrs = false,
+      isDynamic = false;
     switch (node.type) {
       case 16 /* AttrTag */:
-        (_a = node.body) == null ? void 0 : _a.forEach((child) => {
-          if (this.#visitNode(child))
-            hasDynamicBody = true;
-        });
+        (_a = node.body) == null
+          ? void 0
+          : _a.forEach((child) => {
+              if (this.#visitNode(child)) hasDynamicBody = true;
+            });
         break;
       case 1 /* Tag */: {
         const nodeId = `${this.#nodeIdCounter++}`;
@@ -3466,10 +3898,11 @@ var HTMLExtractor = class {
         this.#extractor.copy(node);
         break;
       case 22 /* Placeholder */:
-        isDynamic = this.#read({
-          start: node.start + 1,
-          end: node.start + 2
-        }) === "!";
+        isDynamic =
+          this.#read({
+            start: node.start + 1,
+            end: node.start + 2,
+          }) === "!";
         this.#extractor.write("placeholder");
         break;
     }
@@ -3477,7 +3910,8 @@ var HTMLExtractor = class {
   }
   #writeTag(node, id) {
     const isDynamic = !node.nameText || !isHTMLTag(node.nameText);
-    let hasDynamicAttrs = false, hasDynamicBody = false;
+    let hasDynamicAttrs = false,
+      hasDynamicBody = false;
     if (!isDynamic) {
       ({ hasDynamicAttrs, hasDynamicBody } = this.#writeHTMLTag(node, id));
     } else {
@@ -3487,22 +3921,24 @@ var HTMLExtractor = class {
   }
   #writeHTMLTag(node, id) {
     var _a, _b;
-    let hasDynamicAttrs = false, hasDynamicBody = false;
+    let hasDynamicAttrs = false,
+      hasDynamicBody = false;
     this.#extractor.write("<");
     this.#extractor.copy(node.name);
     this.#extractor.write(` data-marko-node-id="${id}"`);
-    (_a = node.attrs) == null ? void 0 : _a.forEach((attr) => {
-      if (attr.type === 10 /* AttrNamed */)
-        this.#writeAttrNamed(attr);
-      else if (attr.type === 15 /* AttrSpread */)
-        hasDynamicAttrs = true;
-    });
+    (_a = node.attrs) == null
+      ? void 0
+      : _a.forEach((attr) => {
+          if (attr.type === 10 /* AttrNamed */) this.#writeAttrNamed(attr);
+          else if (attr.type === 15 /* AttrSpread */) hasDynamicAttrs = true;
+        });
     this.#extractor.write(">");
     if (!isVoidTag(node.nameText)) {
-      (_b = node.body) == null ? void 0 : _b.forEach((child) => {
-        if (this.#visitNode(child))
-          hasDynamicBody = true;
-      });
+      (_b = node.body) == null
+        ? void 0
+        : _b.forEach((child) => {
+            if (this.#visitNode(child)) hasDynamicBody = true;
+          });
       this.#extractor.write(`</${node.nameText}>`);
     }
     return { hasDynamicAttrs, hasDynamicBody };
@@ -3517,13 +3953,16 @@ var HTMLExtractor = class {
   #writeAttrNamed(attr) {
     this.#extractor.write(" ");
     this.#extractor.copy(attr.name);
-    if (attr.value === void 0 || attr.name.start === attr.name.end || attr.value.type === 14 /* AttrMethod */) {
+    if (
+      attr.value === void 0 ||
+      attr.name.start === attr.name.end ||
+      attr.value.type === 14 /* AttrMethod */
+    ) {
       return;
     }
     const valueString = this.#read(attr.value);
     const valueType = getAttributeValueType(valueString);
-    if (valueType === void 0)
-      return;
+    if (valueType === void 0) return;
     switch (valueType) {
       case 0 /* True */:
         break;
@@ -3531,7 +3970,7 @@ var HTMLExtractor = class {
         this.#extractor.write('="');
         this.#extractor.copy({
           start: attr.value.start + valueString.search(/[^=\s]/g),
-          end: attr.value.end
+          end: attr.value.end,
         });
         this.#extractor.write('"');
         break;
@@ -3539,7 +3978,7 @@ var HTMLExtractor = class {
         this.#extractor.write('="');
         this.#extractor.copy({
           start: attr.value.start + valueString.search(/[^=\s]/g) + 1,
-          end: attr.value.end - 1
+          end: attr.value.end - 1,
         });
         this.#extractor.write('"');
         break;
@@ -3571,19 +4010,20 @@ function isVoidTag(tagName) {
   }
 }
 // Annotate the CommonJS export names for ESM import in node:
-0 && (module.exports = {
-  NodeType,
-  Processors,
-  Project,
-  ScriptLang,
-  UNFINISHED,
-  extractHTML,
-  extractScript,
-  extractStyle,
-  getExt,
-  getLines,
-  getLocation,
-  getPosition,
-  isDefinitionFile,
-  parse
-});
+0 &&
+  (module.exports = {
+    NodeType,
+    Processors,
+    Project,
+    ScriptLang,
+    UNFINISHED,
+    extractHTML,
+    extractScript,
+    extractStyle,
+    getExt,
+    getLines,
+    getLocation,
+    getPosition,
+    isDefinitionFile,
+    parse,
+  });
diff --git a/dist/index.mjs b/dist/index.mjs
index 45a7885906544c72158079694f27dbfb07219fcf..a656ce299410a9b4a6231d4cb89cc465521b85bd 100644
--- a/dist/index.mjs
+++ b/dist/index.mjs
@@ -10,8 +10,7 @@ import { TagType, createParser } from "htmljs-parser";
 // src/util/get-node-at-offset.ts
 function getNodeAtOffset(offset, program) {
   const childNode = childAtOffset(offset, program.body);
-  if (childNode)
-    return visitChildNode(offset, childNode);
+  if (childNode) return visitChildNode(offset, childNode);
   return childAtOffset(offset, program.static) || program;
 }
 function visitChildNode(offset, child) {
@@ -75,11 +74,10 @@ function visitAttrNode(offset, attr) {
 }
 function childAtOffset(offset, children) {
   let max = children.length - 1;
-  if (max === -1)
-    return void 0;
+  if (max === -1) return void 0;
   let min = 0;
   while (min < max) {
-    const mid = 1 + min + max >>> 1;
+    const mid = (1 + min + max) >>> 1;
     if (children[mid].start < offset) {
       min = mid;
     } else {
@@ -91,43 +89,39 @@ function childAtOffset(offset, children) {
 }
 
 // src/parser.ts
-import {
-  getLines,
-  getPosition,
-  getLocation
-} from "htmljs-parser";
+import { getLines, getPosition, getLocation } from "htmljs-parser";
 var styleBlockReg = /((?:\.[^\s\\/:*?"<>|({]+)*)\s*\{/y;
 var UNFINISHED = Number.MAX_SAFE_INTEGER;
 var NodeType = /* @__PURE__ */ ((NodeType2) => {
-  NodeType2[NodeType2["Program"] = 0] = "Program";
-  NodeType2[NodeType2["Tag"] = 1] = "Tag";
-  NodeType2[NodeType2["OpenTagName"] = 2] = "OpenTagName";
-  NodeType2[NodeType2["ShorthandId"] = 3] = "ShorthandId";
-  NodeType2[NodeType2["ShorthandClassName"] = 4] = "ShorthandClassName";
-  NodeType2[NodeType2["TagTypeArgs"] = 5] = "TagTypeArgs";
-  NodeType2[NodeType2["TagTypeParams"] = 6] = "TagTypeParams";
-  NodeType2[NodeType2["TagVar"] = 7] = "TagVar";
-  NodeType2[NodeType2["TagArgs"] = 8] = "TagArgs";
-  NodeType2[NodeType2["TagParams"] = 9] = "TagParams";
-  NodeType2[NodeType2["AttrNamed"] = 10] = "AttrNamed";
-  NodeType2[NodeType2["AttrName"] = 11] = "AttrName";
-  NodeType2[NodeType2["AttrArgs"] = 12] = "AttrArgs";
-  NodeType2[NodeType2["AttrValue"] = 13] = "AttrValue";
-  NodeType2[NodeType2["AttrMethod"] = 14] = "AttrMethod";
-  NodeType2[NodeType2["AttrSpread"] = 15] = "AttrSpread";
-  NodeType2[NodeType2["AttrTag"] = 16] = "AttrTag";
-  NodeType2[NodeType2["Text"] = 17] = "Text";
-  NodeType2[NodeType2["CDATA"] = 18] = "CDATA";
-  NodeType2[NodeType2["Doctype"] = 19] = "Doctype";
-  NodeType2[NodeType2["Declaration"] = 20] = "Declaration";
-  NodeType2[NodeType2["Comment"] = 21] = "Comment";
-  NodeType2[NodeType2["Placeholder"] = 22] = "Placeholder";
-  NodeType2[NodeType2["Scriptlet"] = 23] = "Scriptlet";
-  NodeType2[NodeType2["Import"] = 24] = "Import";
-  NodeType2[NodeType2["Export"] = 25] = "Export";
-  NodeType2[NodeType2["Class"] = 26] = "Class";
-  NodeType2[NodeType2["Style"] = 27] = "Style";
-  NodeType2[NodeType2["Static"] = 28] = "Static";
+  NodeType2[(NodeType2["Program"] = 0)] = "Program";
+  NodeType2[(NodeType2["Tag"] = 1)] = "Tag";
+  NodeType2[(NodeType2["OpenTagName"] = 2)] = "OpenTagName";
+  NodeType2[(NodeType2["ShorthandId"] = 3)] = "ShorthandId";
+  NodeType2[(NodeType2["ShorthandClassName"] = 4)] = "ShorthandClassName";
+  NodeType2[(NodeType2["TagTypeArgs"] = 5)] = "TagTypeArgs";
+  NodeType2[(NodeType2["TagTypeParams"] = 6)] = "TagTypeParams";
+  NodeType2[(NodeType2["TagVar"] = 7)] = "TagVar";
+  NodeType2[(NodeType2["TagArgs"] = 8)] = "TagArgs";
+  NodeType2[(NodeType2["TagParams"] = 9)] = "TagParams";
+  NodeType2[(NodeType2["AttrNamed"] = 10)] = "AttrNamed";
+  NodeType2[(NodeType2["AttrName"] = 11)] = "AttrName";
+  NodeType2[(NodeType2["AttrArgs"] = 12)] = "AttrArgs";
+  NodeType2[(NodeType2["AttrValue"] = 13)] = "AttrValue";
+  NodeType2[(NodeType2["AttrMethod"] = 14)] = "AttrMethod";
+  NodeType2[(NodeType2["AttrSpread"] = 15)] = "AttrSpread";
+  NodeType2[(NodeType2["AttrTag"] = 16)] = "AttrTag";
+  NodeType2[(NodeType2["Text"] = 17)] = "Text";
+  NodeType2[(NodeType2["CDATA"] = 18)] = "CDATA";
+  NodeType2[(NodeType2["Doctype"] = 19)] = "Doctype";
+  NodeType2[(NodeType2["Declaration"] = 20)] = "Declaration";
+  NodeType2[(NodeType2["Comment"] = 21)] = "Comment";
+  NodeType2[(NodeType2["Placeholder"] = 22)] = "Placeholder";
+  NodeType2[(NodeType2["Scriptlet"] = 23)] = "Scriptlet";
+  NodeType2[(NodeType2["Import"] = 24)] = "Import";
+  NodeType2[(NodeType2["Export"] = 25)] = "Export";
+  NodeType2[(NodeType2["Class"] = 26)] = "Class";
+  NodeType2[(NodeType2["Style"] = 27)] = "Style";
+  NodeType2[(NodeType2["Static"] = 28)] = "Static";
   return NodeType2;
 })(NodeType || {});
 function parse(code, filename = "index.marko") {
@@ -142,7 +136,8 @@ function parse(code, filename = "index.marko") {
     nodeAt: (offset) => getNodeAtOffset(offset, program),
     filename,
     program,
-    code
+    code,
+    errors: builder.errors,
   };
 }
 var Builder = class {
@@ -153,6 +148,7 @@ var Builder = class {
   #staticNode;
   #attrNode;
   #comments;
+  errors;
   constructor(code) {
     this.#code = code;
     this.#program = this.#parentNode = {
@@ -162,19 +158,26 @@ var Builder = class {
       static: [],
       body: [],
       start: 0,
-      end: code.length
+      end: code.length,
     };
   }
   end() {
     this.#program.comments = this.#comments;
     return this.#program;
   }
+  onError(range) {
+    if (this.errors) {
+      this.errors.push(range);
+    } else {
+      this.errors = [range];
+    }
+  }
   onText(range) {
     pushBody(this.#parentNode, {
       type: 17 /* Text */,
       parent: this.#parentNode,
       start: range.start,
-      end: range.end
+      end: range.end,
     });
   }
   onCDATA(range) {
@@ -183,7 +186,7 @@ var Builder = class {
       parent: this.#parentNode,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     });
   }
   onDoctype(range) {
@@ -192,7 +195,7 @@ var Builder = class {
       parent: this.#parentNode,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     });
   }
   onDeclaration(range) {
@@ -201,7 +204,7 @@ var Builder = class {
       parent: this.#parentNode,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     });
   }
   onComment(range) {
@@ -210,7 +213,7 @@ var Builder = class {
       parent: this.#parentNode,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
     if (this.#comments) {
       this.#comments.push(comment);
@@ -226,7 +229,7 @@ var Builder = class {
       value: range.value,
       escape: range.escape,
       start: range.start,
-      end: range.end
+      end: range.end,
     });
     this.#comments = void 0;
   }
@@ -238,7 +241,7 @@ var Builder = class {
       value: range.value,
       block: range.block,
       start: range.start,
-      end: range.end
+      end: range.end,
     });
     this.#comments = void 0;
   }
@@ -248,7 +251,7 @@ var Builder = class {
   onOpenTagName(range) {
     let concise = true;
     let start = range.start;
-    let type = 1 /* Tag */;
+    let type = 1; /* Tag */
     let bodyType = TagType.html;
     let nameText = void 0;
     if (this.#openTagStart) {
@@ -257,25 +260,25 @@ var Builder = class {
       this.#openTagStart = void 0;
     }
     if (!range.expressions.length) {
-      switch (nameText = this.#code.slice(range.start, range.end)) {
+      switch ((nameText = this.#code.slice(range.start, range.end))) {
         case "style": {
           styleBlockReg.lastIndex = range.end;
           const styleBlockMatch = styleBlockReg.exec(this.#code);
           if (styleBlockMatch) {
             const [{ length }, ext] = styleBlockMatch;
             this.#program.static.push(
-              this.#staticNode = {
+              (this.#staticNode = {
                 type: 27 /* Style */,
                 parent: this.#program,
                 comments: this.#comments,
                 ext: ext || void 0,
                 value: {
                   start: range.end + length,
-                  end: UNFINISHED
+                  end: UNFINISHED,
                 },
                 start: range.start,
-                end: UNFINISHED
-              }
+                end: UNFINISHED,
+              })
             );
             this.#comments = void 0;
             return TagType.statement;
@@ -286,49 +289,49 @@ var Builder = class {
         }
         case "class":
           this.#program.static.push(
-            this.#staticNode = {
+            (this.#staticNode = {
               type: 26 /* Class */,
               parent: this.#program,
               comments: this.#comments,
               start: range.start,
-              end: UNFINISHED
-            }
+              end: UNFINISHED,
+            })
           );
           this.#comments = void 0;
           return TagType.statement;
         case "export":
           this.#program.static.push(
-            this.#staticNode = {
+            (this.#staticNode = {
               type: 25 /* Export */,
               parent: this.#program,
               comments: this.#comments,
               start: range.start,
-              end: UNFINISHED
-            }
+              end: UNFINISHED,
+            })
           );
           this.#comments = void 0;
           return TagType.statement;
         case "import":
           this.#program.static.push(
-            this.#staticNode = {
+            (this.#staticNode = {
               type: 24 /* Import */,
               parent: this.#program,
               comments: this.#comments,
               start: range.start,
-              end: UNFINISHED
-            }
+              end: UNFINISHED,
+            })
           );
           this.#comments = void 0;
           return TagType.statement;
         case "static":
           this.#program.static.push(
-            this.#staticNode = {
+            (this.#staticNode = {
               type: 28 /* Static */,
               parent: this.#program,
               comments: this.#comments,
               start: range.start,
-              end: UNFINISHED
-            }
+              end: UNFINISHED,
+            })
           );
           this.#comments = void 0;
           return TagType.statement;
@@ -368,33 +371,36 @@ var Builder = class {
       quasis: range.quasis,
       expressions: range.expressions,
       start: range.start,
-      end: range.end
-    };
-    const tag = this.#parentNode = name.parent = {
-      type,
-      parent,
-      comments: this.#comments,
-      owner: void 0,
-      concise,
-      selfClosed: false,
-      hasAttrTags: false,
-      open: { start, end },
-      nameText,
-      name,
-      var: void 0,
-      args: void 0,
-      params: void 0,
-      shorthandId: void 0,
-      shorthandClassNames: void 0,
-      typeArgs: void 0,
-      typeParams: void 0,
-      attrs: void 0,
-      bodyType,
-      body: void 0,
-      close: void 0,
-      start,
-      end
+      end: range.end,
     };
+    const tag =
+      (this.#parentNode =
+      name.parent =
+        {
+          type,
+          parent,
+          comments: this.#comments,
+          owner: void 0,
+          concise,
+          selfClosed: false,
+          hasAttrTags: false,
+          open: { start, end },
+          nameText,
+          name,
+          var: void 0,
+          args: void 0,
+          params: void 0,
+          shorthandId: void 0,
+          shorthandClassNames: void 0,
+          typeArgs: void 0,
+          typeParams: void 0,
+          attrs: void 0,
+          bodyType,
+          body: void 0,
+          close: void 0,
+          start,
+          end,
+        });
     this.#comments = void 0;
     if (tag.type === 16 /* AttrTag */) {
       let parentTag = parent;
@@ -429,7 +435,7 @@ var Builder = class {
       quasis: range.quasis,
       expressions: range.expressions,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
   }
   onTagShorthandClass(range) {
@@ -440,7 +446,7 @@ var Builder = class {
       quasis: range.quasis,
       expressions: range.expressions,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
     if (parent.shorthandClassNames) {
       parent.shorthandClassNames.push(shorthandClassName);
@@ -455,7 +461,7 @@ var Builder = class {
       parent,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
   }
   onTagTypeParams(range) {
@@ -465,7 +471,7 @@ var Builder = class {
       parent,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
   }
   onTagVar(range) {
@@ -475,7 +481,7 @@ var Builder = class {
       parent,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
   }
   onTagParams(range) {
@@ -485,7 +491,7 @@ var Builder = class {
       parent,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
   }
   onTagArgs(range) {
@@ -495,7 +501,7 @@ var Builder = class {
       parent,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
   }
   onAttrName(range) {
@@ -504,19 +510,20 @@ var Builder = class {
       type: 11 /* AttrName */,
       parent: void 0,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
     pushAttr(
       parent,
-      this.#attrNode = name.parent = {
-        type: 10 /* AttrNamed */,
-        parent,
-        name,
-        value: void 0,
-        args: void 0,
-        start: range.start,
-        end: range.end
-      }
+      (this.#attrNode = name.parent =
+        {
+          type: 10 /* AttrNamed */,
+          parent,
+          name,
+          value: void 0,
+          args: void 0,
+          start: range.start,
+          end: range.end,
+        })
     );
   }
   onAttrArgs(range) {
@@ -526,7 +533,7 @@ var Builder = class {
       parent,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
     parent.end = range.end;
   }
@@ -538,7 +545,7 @@ var Builder = class {
       value: range.value,
       bound: range.bound,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
     parent.end = range.end;
   }
@@ -551,7 +558,7 @@ var Builder = class {
       params: range.params,
       body: range.body,
       start: range.start,
-      end: range.end
+      end: range.end,
     };
     parent.end = range.end;
   }
@@ -562,7 +569,7 @@ var Builder = class {
       parent,
       value: range.value,
       start: range.start,
-      end: range.end
+      end: range.end,
     });
   }
   onOpenTagEnd(range) {
@@ -586,13 +593,12 @@ var Builder = class {
   onCloseTagStart(range) {
     this.#parentNode.close = {
       start: range.start,
-      end: UNFINISHED
+      end: UNFINISHED,
     };
   }
   onCloseTagEnd(range) {
     const parent = this.#parentNode;
-    if (hasCloseTag(parent))
-      parent.close.end = range.end;
+    if (hasCloseTag(parent)) parent.close.end = range.end;
     parent.end = range.end;
     this.#parentNode = parent.parent;
   }
@@ -634,12 +640,12 @@ var emptyView = {
   },
   rangeAt(_start, _end) {
     return;
-  }
+  },
 };
 var Extractor = class {
   #parsed;
   #generated = "";
-  #tokens = [];
+  tokens = [];
   constructor(parsed) {
     this.#parsed = parsed;
   }
@@ -652,10 +658,10 @@ var Extractor = class {
       if (typeof range === "string") {
         this.#generated += range;
       } else {
-        this.#tokens.push({
+        this.tokens.push({
           generatedStart: this.#generated.length,
           sourceStart: range.start,
-          length: Math.min(this.#parsed.code.length, range.end) - range.start
+          length: Math.min(this.#parsed.code.length, range.end) - range.start,
         });
         this.#generated += this.#parsed.read(range);
       }
@@ -663,13 +669,14 @@ var Extractor = class {
     return this;
   }
   end() {
-    return new Extracted(this.#parsed, this.#generated, this.#tokens);
+    return new Extracted(this.#parsed, this.#generated, this.tokens);
   }
 };
 var Extracted = class {
   constructor(parsed, generated, tokens) {
     this.parsed = parsed;
     this.#generated = generated;
+    this.tokens = tokens;
     if (tokens.length === 0) {
       this.#generatedToSource = this.#sourceToGenerated = emptyView;
     } else {
@@ -684,15 +691,17 @@ var Extracted = class {
   #generatedToSource;
   #cachedGeneratedLines;
   get #generatedLines() {
-    return this.#cachedGeneratedLines || (this.#cachedGeneratedLines = getLines(this.#generated));
+    return (
+      this.#cachedGeneratedLines ||
+      (this.#cachedGeneratedLines = getLines(this.#generated))
+    );
   }
   sourceOffsetAt(generatedOffset) {
     return this.#generatedToSource.offsetAt(generatedOffset);
   }
   sourcePositionAt(generatedOffset) {
     const sourceOffset = this.sourceOffsetAt(generatedOffset);
-    if (sourceOffset !== void 0)
-      return this.parsed.positionAt(sourceOffset);
+    if (sourceOffset !== void 0) return this.parsed.positionAt(sourceOffset);
   }
   sourceLocationAt(generatedStart, generatedEnd) {
     const sourceRange = this.#generatedToSource.rangeAt(
@@ -730,24 +739,24 @@ var Extracted = class {
   }
 };
 var TokenView = class {
-  #tokens;
+  tokens;
   #last;
   constructor(tokens) {
-    this.#tokens = tokens;
+    this.tokens = tokens;
     this.#last = tokens.length - 1;
   }
   offsetAt(offset) {
     let min = 0;
     let max = this.#last;
     while (min < max) {
-      const mid = 1 + min + max >>> 1;
-      if (this.inStart(this.#tokens[mid]) <= offset) {
+      const mid = (1 + min + max) >>> 1;
+      if (this.inStart(this.tokens[mid]) <= offset) {
         min = mid;
       } else {
         max = mid - 1;
       }
     }
-    const token = this.#tokens[min];
+    const token = this.tokens[min];
     const index = offset - this.inStart(token);
     if (index >= 0 && index <= token.length) {
       return this.outStart(token) + index;
@@ -757,8 +766,8 @@ var TokenView = class {
     let min = 0;
     let max = this.#last;
     while (min < max) {
-      const mid = min + max >> 1;
-      const token = this.#tokens[mid];
+      const mid = (min + max) >> 1;
+      const token = this.tokens[mid];
       const tokenInEnd = this.inStart(token) + token.length;
       if (tokenInEnd > inStart) {
         max = mid;
@@ -766,14 +775,13 @@ var TokenView = class {
         min = mid + 1;
       }
     }
-    const startToken = this.#tokens[max];
+    const startToken = this.tokens[max];
     const startTokenInStart = this.inStart(startToken);
-    if (startTokenInStart >= inEnd)
-      return;
+    if (startTokenInStart >= inEnd) return;
     max = this.#last;
     while (min < max) {
-      const mid = 1 + min + max >>> 1;
-      const token = this.#tokens[mid];
+      const mid = (1 + min + max) >>> 1;
+      const token = this.tokens[mid];
       const tokenEnd = this.inStart(token) + token.length;
       if (tokenEnd <= inEnd) {
         min = mid;
@@ -781,11 +789,10 @@ var TokenView = class {
         max = mid - 1;
       }
     }
-    const endToken = this.#tokens[min];
+    const endToken = this.tokens[min];
     const endTokenInStart = this.inStart(endToken);
     const endTokenInEnd = endTokenInStart + endToken.length;
-    if (endTokenInEnd < inStart)
-      return;
+    if (endTokenInEnd < inStart) return;
     const startIndex = inStart - startTokenInStart;
     const endIndex = inEnd - endTokenInStart;
     const start = this.outStart(startToken) + Math.max(0, startIndex);
@@ -846,7 +853,9 @@ function extractStyle(opts) {
       case 1 /* Tag */:
         if (node.body) {
           if (node.nameText === "style") {
-            const ext = node.shorthandClassNames ? read(node.shorthandClassNames.at(-1)) : ".css";
+            const ext = node.shorthandClassNames
+              ? read(node.shorthandClassNames.at(-1))
+              : ".css";
             for (const child of node.body) {
               switch (child.type) {
                 case 17 /* Text */:
@@ -867,14 +876,28 @@ function extractStyle(opts) {
           for (const attr of node.attrs) {
             if (
               // Check for string literal attribute values.
-              attr.type === 10 /* AttrNamed */ && ((_a = attr.value) == null ? void 0 : _a.type) === 13 /* AttrValue */ && /^['"]$/.test(code[attr.value.value.start])
+              attr.type === 10 /* AttrNamed */ &&
+              ((_a = attr.value) == null ? void 0 : _a.type) ===
+                13 /* AttrValue */ &&
+              /^['"]$/.test(code[attr.value.value.start])
             ) {
               const name = read(attr.name);
-              if (name === "#style" || name === "style" && node.nameText && name === "style" && ((_b = lookup.getTag(node.nameText)) == null ? void 0 : _b.html)) {
-                getExtractor("css").write(":root{").copy({
-                  start: attr.value.value.start + 1,
-                  end: attr.value.value.end - 1
-                }).write("}");
+              if (
+                name === "#style" ||
+                (name === "style" &&
+                  node.nameText &&
+                  name === "style" &&
+                  ((_b = lookup.getTag(node.nameText)) == null
+                    ? void 0
+                    : _b.html))
+              ) {
+                getExtractor("css")
+                  .write(":root{")
+                  .copy({
+                    start: attr.value.value.start + 1,
+                    end: attr.value.value.end - 1,
+                  })
+                  .write("}");
               }
             }
           }
@@ -885,7 +908,7 @@ function extractStyle(opts) {
   function getExtractor(ext) {
     let extractor = extractorsByExt.get(ext);
     if (!extractor) {
-      extractorsByExt.set(ext, extractor = new Extractor(parsed));
+      extractorsByExt.set(ext, (extractor = new Extractor(parsed)));
     }
     return extractor;
   }
@@ -895,15 +918,8 @@ function extractStyle(opts) {
 import { relativeImportPath } from "relative-import-path";
 
 // src/extractors/script/util/script-parser.ts
-import {
-  parseExpression,
-  parse as parseStatement
-} from "@babel/parser";
-var plugins = [
-  "exportDefaultFrom",
-  "importAssertions",
-  "typescript"
-];
+import { parseExpression, parse as parseStatement } from "@babel/parser";
+var plugins = ["exportDefaultFrom", "importAssertions", "typescript"];
 var ScriptParser = class {
   #sourceFileName;
   #whitespace;
@@ -922,7 +938,7 @@ var ScriptParser = class {
         allowSuperOutsideMethod: true,
         allowAwaitOutsideFunction: true,
         allowReturnOutsideFunction: true,
-        sourceFilename: this.#sourceFileName
+        sourceFilename: this.#sourceFileName,
       }).program.body;
     } catch {
       return [];
@@ -939,7 +955,7 @@ var ScriptParser = class {
         allowSuperOutsideMethod: true,
         allowAwaitOutsideFunction: true,
         allowReturnOutsideFunction: true,
-        sourceFilename: this.#sourceFileName
+        sourceFilename: this.#sourceFileName,
       });
     } catch {
       return;
@@ -951,10 +967,14 @@ var ScriptParser = class {
 import {
   isIdentifierName,
   isKeyword,
-  isStrictBindReservedWord
+  isStrictBindReservedWord,
 } from "@babel/helper-validator-identifier";
 function isValidIdentifier(name) {
-  return isIdentifierName(name) && !isKeyword(name) && !isStrictBindReservedWord(name, true);
+  return (
+    isIdentifierName(name) &&
+    !isKeyword(name) &&
+    !isStrictBindReservedWord(name, true)
+  );
 }
 
 // src/extractors/script/util/attach-scopes.ts
@@ -971,7 +991,7 @@ function crawlProgramScope(parsed, scriptParser) {
   const programScope = {
     parent: void 0,
     hoists: false,
-    bindings: {}
+    bindings: {},
   };
   programScope.bindings.input = {
     type: 0 /* var */,
@@ -981,7 +1001,7 @@ function crawlProgramScope(parsed, scriptParser) {
     hoisted: false,
     mutated: false,
     sourceName: void 0,
-    objectPath: void 0
+    objectPath: void 0,
   };
   visit(program.body, programScope);
   Scopes.set(program.body, programScope);
@@ -990,7 +1010,8 @@ function crawlProgramScope(parsed, scriptParser) {
     const parentScope = scope.parent;
     let curParent = parentScope;
     while (curParent) {
-      const parentBinding = (_a = curParent.bindings) == null ? void 0 : _a[name];
+      const parentBinding =
+        (_a = curParent.bindings) == null ? void 0 : _a[name];
       if (parentBinding) {
         if (parentBinding.type === 2 /* hoisted */) {
           binding.hoisted = true;
@@ -1004,7 +1025,7 @@ function crawlProgramScope(parsed, scriptParser) {
           type: 2 /* hoisted */,
           scope: programScope,
           bindings: [binding],
-          hoisted: false
+          hoisted: false,
         };
         break;
       }
@@ -1034,7 +1055,10 @@ function crawlProgramScope(parsed, scriptParser) {
         case 16 /* AttrTag */: {
           if (child.var) {
             parentScope.bindings ??= {};
-            const parsedFn = scriptParser.expressionAt(child.var.value.start - 6, `${read(child.var.value)}=0`);
+            const parsedFn = scriptParser.expressionAt(
+              child.var.value.start - 6,
+              `${read(child.var.value)}=0`
+            );
             if (parsedFn) {
               const lVal = parsedFn.left;
               checkForMutations(parentScope, lVal);
@@ -1045,7 +1069,7 @@ function crawlProgramScope(parsed, scriptParser) {
                 ATTR_UNAMED
               )) {
                 const { name, objectPath, sourceName } = id;
-                const binding = parentScope.bindings[name] = {
+                const binding = (parentScope.bindings[name] = {
                   type: 0 /* var */,
                   name,
                   node: child,
@@ -1053,8 +1077,8 @@ function crawlProgramScope(parsed, scriptParser) {
                   hoisted: false,
                   mutated: false,
                   objectPath,
-                  sourceName
-                };
+                  sourceName,
+                });
                 potentialHoists.push(binding);
               }
             }
@@ -1063,7 +1087,7 @@ function crawlProgramScope(parsed, scriptParser) {
             const bodyScope = {
               parent: parentScope,
               hoists: false,
-              bindings: {}
+              bindings: {},
             };
             if (child.params) {
               bodyScope.bindings ??= {};
@@ -1080,7 +1104,7 @@ function crawlProgramScope(parsed, scriptParser) {
                       name,
                       node: child,
                       scope: bodyScope,
-                      hoisted: false
+                      hoisted: false,
                     };
                   }
                 }
@@ -1144,7 +1168,7 @@ function crawlProgramScope(parsed, scriptParser) {
                           attr.value.params.start - 2,
                           `{_${read({
                             start: attr.value.params.start,
-                            end: attr.value.body.end
+                            end: attr.value.body.end,
                           })}}`
                         )
                       );
@@ -1220,7 +1244,9 @@ function getMutatedVars(node) {
 function isMutatedVar(node, name) {
   const { bindings } = Scopes.get(node.body);
   const binding = bindings == null ? void 0 : bindings[name];
-  return (binding == null ? void 0 : binding.type) === 0 /* var */ && binding.mutated;
+  return (
+    (binding == null ? void 0 : binding.type) === 0 /* var */ && binding.mutated
+  );
 }
 function hasHoists(node) {
   return node.body ? Scopes.get(node.body).hoists : false;
@@ -1233,10 +1259,13 @@ function resolveWritableVar(scope, name) {
   let curScope = scope;
   do {
     const binding = (_a = curScope.bindings) == null ? void 0 : _a[name];
-    if ((binding == null ? void 0 : binding.type) === 0 /* var */ && binding.sourceName !== void 0) {
+    if (
+      (binding == null ? void 0 : binding.type) === 0 /* var */ &&
+      binding.sourceName !== void 0
+    ) {
       return binding;
     }
-  } while (curScope = curScope.parent);
+  } while ((curScope = curScope.parent));
 }
 function* getIdentifiers(lVal) {
   switch (lVal.type) {
@@ -1274,7 +1303,7 @@ function* getVarIdentifiers(parsed, lVal, objectPath, sourceName) {
       yield {
         name: lVal.name,
         objectPath,
-        sourceName
+        sourceName,
       };
       break;
     case "ObjectPattern":
@@ -1332,14 +1361,27 @@ function trackMutationsInClosures(root, scope, mutations) {
       case "ArrowFunctionExpression":
       case "ClassMethod":
       case "ClassPrivateMethod":
-        trackMutations(node, scope, mutations, node, /* @__PURE__ */ new Set(), []);
+        trackMutations(
+          node,
+          scope,
+          mutations,
+          node,
+          /* @__PURE__ */ new Set(),
+          []
+        );
         return true;
     }
   });
 }
-function trackMutations(node, scope, mutations, parentBlock, parentBlockShadows, parentBlockMutations) {
-  if (!node)
-    return;
+function trackMutations(
+  node,
+  scope,
+  mutations,
+  parentBlock,
+  parentBlockShadows,
+  parentBlockMutations
+) {
+  if (!node) return;
   let block = parentBlock;
   let blockShadows = parentBlockShadows;
   let blockMutations = parentBlockMutations;
@@ -1462,8 +1504,7 @@ function trackMutations(node, scope, mutations, parentBlock, parentBlockShadows,
   }
   if (block !== parentBlock && blockMutations.length) {
     for (const { name, start } of blockMutations) {
-      if (blockShadows.has(name))
-        continue;
+      if (blockShadows.has(name)) continue;
       const binding = resolveWritableVar(scope, name);
       if (binding) {
         binding.mutated = true;
@@ -1480,10 +1521,8 @@ function trackShadows(node, scope, shadows) {
   }
 }
 function traverse(node, enter) {
-  if (!node)
-    return;
-  if (enter(node))
-    return;
+  if (!node) return;
+  if (enter(node)) return;
   for (const key of t.VISITOR_KEYS[node.type]) {
     const child = node[key];
     if (Array.isArray(child)) {
@@ -1506,7 +1545,9 @@ function getComponentFilename(from) {
     nameNoExt = nameNoExt.slice(0, -2);
   }
   const isEntry = nameNoExt === "index";
-  const fileMatch = `(${nameNoExt.replace(/[.*+?^$[\]()|\\:!{}]/g, "\\$&")}\\.${isEntry ? "|" : ""})`;
+  const fileMatch = `(${nameNoExt.replace(/[.*+?^$[\]()|\\:!{}]/g, "\\$&")}\\.${
+    isEntry ? "|" : ""
+  })`;
   const componentMatch = new RegExp(
     `^${fileMatch}component(-browser)?\\.\\w+$`
   );
@@ -1527,19 +1568,21 @@ function tryReaddirSync(dir) {
 // src/extractors/script/util/runtime-overrides.ts
 var RuntimeOverloads = /* @__PURE__ */ new Map();
 var commentsReg = /\/\*(?:[^*]+|\*[^/])*\*\//gm;
-var replaceTokensReg = /\babstract\s+(\w+)|Marko\.(TemplateInput(?:<[^>]+>)?|Component)/gm;
-var overrideBlockReg = /\/\*[*\s]*@marko-overload-start[*\s]*\*\/([\s\S]+)\/\*[*\s]*@marko-overload-end[*\s]*\*\//g;
+var replaceTokensReg =
+  /\babstract\s+(\w+)|Marko\.(TemplateInput(?:<[^>]+>)?|Component)/gm;
+var overrideBlockReg =
+  /\/\*[*\s]*@marko-overload-start[*\s]*\*\/([\s\S]+)\/\*[*\s]*@marko-overload-end[*\s]*\*\//g;
 function getRuntimeOverrides(runtimeTypes, generics, applyGenerics) {
   let overloads = RuntimeOverloads.get(runtimeTypes);
   if (!overloads) {
     const match = overrideBlockReg.exec(runtimeTypes);
-    RuntimeOverloads.set(runtimeTypes, overloads = []);
+    RuntimeOverloads.set(runtimeTypes, (overloads = []));
     if (match) {
       let [, content] = match;
       let replaceMatch;
       let lastIndex = 0;
       content = content.replace(commentsReg, "");
-      while (replaceMatch = replaceTokensReg.exec(content)) {
+      while ((replaceMatch = replaceTokensReg.exec(content))) {
         const [, methodName, propertyName] = replaceMatch;
         const curText = content.slice(lastIndex, replaceMatch.index);
         lastIndex = replaceTokensReg.lastIndex;
@@ -1581,8 +1624,7 @@ function getRuntimeOverrides(runtimeTypes, generics, applyGenerics) {
 var MaybeInputTypedefReg = /@typedef\b[\s\S]*\bInput\b/;
 function getJSDocInputType(comment, ts) {
   var _a, _b, _c, _d;
-  if (!MaybeInputTypedefReg.test(comment))
-    return;
+  if (!MaybeInputTypedefReg.test(comment)) return;
   const sourceFile = ts.createSourceFile(
     "_.js",
     comment,
@@ -1590,18 +1632,23 @@ function getJSDocInputType(comment, ts) {
     false,
     ts.ScriptKind.JS
   );
-  const tags = (_b = (_a = sourceFile.endOfFileToken.jsDoc) == null ? void 0 : _a[0]) == null ? void 0 : _b.tags;
-  if (!(tags && hasInputTypeDef(ts, sourceFile, tags)))
-    return;
+  const tags =
+    (_b = (_a = sourceFile.endOfFileToken.jsDoc) == null ? void 0 : _a[0]) ==
+    null
+      ? void 0
+      : _b.tags;
+  if (!(tags && hasInputTypeDef(ts, sourceFile, tags))) return;
   let typeParameters;
   for (const tag of tags) {
     if (isTemplateTag(ts, tag)) {
-      let constraint = (_c = tag.constraint) == null ? void 0 : _c.type.getText(sourceFile);
+      let constraint =
+        (_c = tag.constraint) == null ? void 0 : _c.type.getText(sourceFile);
       for (const param of tag.typeParameters) {
         const value = {
           name: "" + param.name.escapedText,
           constraint,
-          default: (_d = param.default) == null ? void 0 : _d.getText(sourceFile)
+          default:
+            (_d = param.default) == null ? void 0 : _d.getText(sourceFile),
         };
         constraint = void 0;
         if (typeParameters) {
@@ -1617,7 +1664,11 @@ function getJSDocInputType(comment, ts) {
 function hasInputTypeDef(ts, sourceFile, tags) {
   var _a;
   for (const tag of tags) {
-    if (isTypeDefTag(ts, tag) && ((_a = tag.fullName) == null ? void 0 : _a.getText(sourceFile)) === "Input") {
+    if (
+      isTypeDefTag(ts, tag) &&
+      ((_a = tag.fullName) == null ? void 0 : _a.getText(sourceFile)) ===
+        "Input"
+    ) {
       return true;
     }
   }
@@ -1641,7 +1692,8 @@ var ATTR_UNAMED2 = "value";
 var REG_EXT = /(?<=[/\\][^/\\]+)\.[^.]+$/;
 var REG_BLOCK = /\s*{/y;
 var REG_NEW_LINE = /^|(\r?\n)/g;
-var REG_ATTR_ARG_LITERAL = /(?<=\s*)(["'])((?:[^"'\\]+|\\.|(?!\1))*)\1\s*([,)])/my;
+var REG_ATTR_ARG_LITERAL =
+  /(?<=\s*)(["'])((?:[^"'\\]+|\\.|(?!\1))*)\1\s*([,)])/my;
 var REG_TAG_IMPORT = /(?<=(['"]))<([^\1>]+)>(?=\1)/;
 var REG_INPUT_TYPE = /\s*(interface|type)\s+Input\b/y;
 var REG_OBJECT_PROPERTY = /^[_$a-z][_$a-z0-9]*$/i;
@@ -1700,7 +1752,7 @@ var ScriptExtractor = class {
           this.#writeComments(node);
           componentClassBody = {
             start: node.start + "class".length,
-            end: node.end
+            end: node.end,
           };
           break;
         case 25 /* Export */: {
@@ -1720,13 +1772,17 @@ var ScriptExtractor = class {
             if (templatePath) {
               const [{ length }] = tagImportMatch;
               const fromStart = node.start + tagImportMatch.index;
-              this.#extractor.copy({
-                start: node.start,
-                end: fromStart
-              }).write(templatePath).copy({
-                start: fromStart + length,
-                end: node.end
-              }).write("\n");
+              this.#extractor
+                .copy({
+                  start: node.start,
+                  end: fromStart,
+                })
+                .write(templatePath)
+                .copy({
+                  start: fromStart + length,
+                  end: node.end,
+                })
+                .write("\n");
               break;
             }
           }
@@ -1749,13 +1805,18 @@ var ScriptExtractor = class {
     let typeParamsStr = "";
     let typeArgsStr = "";
     let jsDocTemplateTagsStr = "";
-    const isExternalComponentFile = !componentClassBody && componentFileName !== void 0;
+    const isExternalComponentFile =
+      !componentClassBody && componentFileName !== void 0;
     if (inputType) {
       if (inputType.typeParameters) {
         let sep = SEP_EMPTY;
         typeParamsStr = typeArgsStr = "<";
         for (const param of inputType.typeParameters) {
-          typeParamsStr += sep + param.name + (param.constraint ? ` extends ${param.constraint}` : "") + (param.default ? ` = ${param.default}` : "");
+          typeParamsStr +=
+            sep +
+            param.name +
+            (param.constraint ? ` extends ${param.constraint}` : "") +
+            (param.default ? ` = ${param.default}` : "");
           typeArgsStr += sep + param.name;
           sep = SEP_COMMA_SPACE;
         }
@@ -1764,19 +1825,31 @@ var ScriptExtractor = class {
         if (this.#scriptLang === "js" /* js */) {
           for (const param of inputType.typeParameters) {
             jsDocTemplateTagsStr += `
-* @template ${param.constraint ? `{${removeNewLines(param.constraint)}} ` : ""}${param.default ? `[${param.name} = ${removeNewLines(param.default)}]` : param.name}`;
+* @template ${
+              param.constraint ? `{${removeNewLines(param.constraint)}} ` : ""
+            }${
+              param.default
+                ? `[${param.name} = ${removeNewLines(param.default)}]`
+                : param.name
+            }`;
           }
         }
       }
     } else {
       if (this.#scriptLang === "ts" /* ts */) {
         this.#extractor.write(
-          isExternalComponentFile ? "export type Input = Component['input'];\n" : `export interface Input {}
+          isExternalComponentFile
+            ? "export type Input = Component['input'];\n"
+            : `export interface Input {}
 `
         );
       } else {
         this.#extractor.write(
-          `/** @typedef {${isExternalComponentFile ? "Component['input']" : "Record<string, unknown>"}} Input */
+          `/** @typedef {${
+            isExternalComponentFile
+              ? "Component['input']"
+              : "Record<string, unknown>"
+          }} Input */
 `
         );
       }
@@ -1800,16 +1873,22 @@ var ScriptExtractor = class {
     } else {
       const body2 = componentClassBody || " {}";
       if (this.#scriptLang === "ts" /* ts */) {
-        this.#extractor.write(
-          `abstract class Component${typeParamsStr} extends Marko.Component<Input${typeArgsStr}>`
-        ).copy(body2).write("\nexport { type Component }\n");
+        this.#extractor
+          .write(
+            `abstract class Component${typeParamsStr} extends Marko.Component<Input${typeArgsStr}>`
+          )
+          .copy(body2)
+          .write("\nexport { type Component }\n");
       } else {
         this.#extractor.write(`/**${jsDocTemplateTagsStr}
   * @extends {Marko.Component<Input${typeArgsStr}>}
   * @abstract
   */
 `);
-        this.#extractor.write(`export class Component extends Marko.Component`).copy(body2).write("\n");
+        this.#extractor
+          .write(`export class Component extends Marko.Component`)
+          .copy(body2)
+          .write("\n");
       }
     }
     const didReturn = !!getReturnTag(program);
@@ -1829,7 +1908,9 @@ var ScriptExtractor = class {
 function ${templateName}() {
 `);
     }
-    this.#extractor.write(`  const input = ${this.#getCastedType(`Input${typeArgsStr}`)};
+    this.#extractor.write(`  const input = ${this.#getCastedType(
+      `Input${typeArgsStr}`
+    )};
   const component = ${this.#getCastedType(`Component${typeArgsStr}`)};
   const state = ${varShared("state")}(component);
   const $signal = ${this.#getCastedType("AbortSignal")};
@@ -1871,14 +1952,28 @@ function ${templateName}() {
       "Relate"
     )}<${internalInput}, Marko.Directives & Input${typeArgsStr}>) => (${varShared(
       "ReturnWithScope"
-    )}<${internalInput}, ${didReturn ? `typeof ${templateName + typeArgsStr} extends () => infer Return ? Return : never` : "void"}>)`;
-    const templateOverrideClass = `${templateBaseClass}<{${this.#runtimeTypes ? getRuntimeOverrides(this.#runtimeTypes, typeParamsStr, typeArgsStr) : ""}
-  _${typeParamsStr ? `<${internalApply} = 1>(): ${internalApply} extends 0
+    )}<${internalInput}, ${
+      didReturn
+        ? `typeof ${
+            templateName + typeArgsStr
+          } extends () => infer Return ? Return : never`
+        : "void"
+    }>)`;
+    const templateOverrideClass = `${templateBaseClass}<{${
+      this.#runtimeTypes
+        ? getRuntimeOverrides(this.#runtimeTypes, typeParamsStr, typeArgsStr)
+        : ""
+    }
+  _${
+    typeParamsStr
+      ? `<${internalApply} = 1>(): ${internalApply} extends 0
     ? ${typeParamsStr}() => <${internalInputWithExtends}>${renderAndReturn}
     : () => <${internalInputWithExtends}, ${typeParamsStr.slice(
-      1,
-      -1
-    )}>${renderAndReturn};` : `(): () => <${internalInputWithExtends}>${renderAndReturn};`}
+          1,
+          -1
+        )}>${renderAndReturn};`
+      : `(): () => <${internalInputWithExtends}>${renderAndReturn};`
+  }
 }>`;
     this.#extractor.copy(START_OF_FILE);
     if (this.#scriptLang === "ts" /* ts */) {
@@ -1898,7 +1993,11 @@ function ${templateName}() {
     this.#writeComments(program);
   }
   #writeCommentPragmas(program) {
-    const firstComments = program.static.length ? program.static[0].comments : program.body.length ? program.body[0].comments : program.comments;
+    const firstComments = program.static.length
+      ? program.static[0].comments
+      : program.body.length
+      ? program.body[0].comments
+      : program.comments;
     if (firstComments) {
       for (const comment of firstComments) {
         if (this.#testAtIndex(REG_COMMENT_PRAGMA, comment.start)) {
@@ -1960,8 +2059,7 @@ constructor(_?: Return) {}
               let renderId = this.#getRenderId(child);
               if (!renderId && alternates) {
                 for (const { node } of alternates) {
-                  if (renderId = this.#getRenderId(node))
-                    break;
+                  if ((renderId = this.#getRenderId(node))) break;
                 }
               }
               if (renderId) {
@@ -1973,9 +2071,16 @@ constructor(_?: Return) {}
                 );
               }
               this.#writeComments(child);
-              this.#extractor.write("if (").copy(
-                this.#getRangeWithoutTrailingComma((_a = child.args) == null ? void 0 : _a.value) || this.#getAttrValue(child, ATTR_UNAMED2) || "undefined"
-              ).write(") {\n");
+              this.#extractor
+                .write("if (")
+                .copy(
+                  this.#getRangeWithoutTrailingComma(
+                    (_a = child.args) == null ? void 0 : _a.value
+                  ) ||
+                    this.#getAttrValue(child, ATTR_UNAMED2) ||
+                    "undefined"
+                )
+                .write(") {\n");
               if (child.body) {
                 const localBindings = getHoistSources(child);
                 this.#writeChildren(child, child.body);
@@ -1990,7 +2095,10 @@ constructor(_?: Return) {}
                 for (const { node, condition } of alternates) {
                   this.#writeComments(node);
                   if (condition) {
-                    this.#extractor.write("\n} else if (\n").copy(condition).write("\n) {\n");
+                    this.#extractor
+                      .write("\n} else if (\n")
+                      .copy(condition)
+                      .write("\n) {\n");
                   } else if (node.nameText === "else") {
                     needsAlternate = false;
                     this.#extractor.write("\n} else {\n");
@@ -2030,7 +2138,10 @@ constructor(_?: Return) {}
               this.#extractor.write(`${varShared("forTag")}({
 `);
               this.#writeAttrs(child);
-              this.#extractor.write(`["renderBody"/*`).copy(child.name).write(`*/]: (`);
+              this.#extractor
+                .write(`["renderBody"/*`)
+                .copy(child.name)
+                .write(`*/]: (`);
               this.#writeComments(child);
               this.#extractor.copy(child.typeParams).write("(\n");
               if (child.params) {
@@ -2043,7 +2154,9 @@ constructor(_?: Return) {}
               }
               this.#writeReturn(
                 void 0,
-                (body == null ? void 0 : body.renderBody) ? getHoistSources(child) : void 0
+                (body == null ? void 0 : body.renderBody)
+                  ? getHoistSources(child)
+                  : void 0
               );
               this.#extractor.write("})");
               if (renderId) {
@@ -2055,9 +2168,14 @@ constructor(_?: Return) {}
             }
             case "while": {
               this.#writeComments(child);
-              this.#extractor.write("while (\n").copy(
-                this.#getRangeWithoutTrailingComma((_b = child.args) == null ? void 0 : _b.value) || "undefined"
-              ).write("\n) {\n");
+              this.#extractor
+                .write("while (\n")
+                .copy(
+                  this.#getRangeWithoutTrailingComma(
+                    (_b = child.args) == null ? void 0 : _b.value
+                  ) || "undefined"
+                )
+                .write("\n) {\n");
               const body = this.#processBody(child);
               if (body == null ? void 0 : body.renderBody) {
                 this.#writeChildren(child, body.renderBody);
@@ -2095,8 +2213,15 @@ constructor(_?: Return) {}
 `);
         for (const binding of mutatedVars) {
           this.#extractor.write(
-            `${// TODO use a different format to avoid const annotation.
-            this.#scriptLang === "js" /* js */ ? "/** @type {const} */" : ""}[${JSON.stringify(binding.name) + (binding.sourceName && binding.sourceName !== binding.name ? `, ${JSON.stringify(binding.sourceName)}` : "")}, ${varShared("rendered")}.returns[${this.#getRenderId(
+            `${
+              // TODO use a different format to avoid const annotation.
+              this.#scriptLang === "js" /* js */ ? "/** @type {const} */" : ""
+            }[${
+              JSON.stringify(binding.name) +
+              (binding.sourceName && binding.sourceName !== binding.name
+                ? `, ${JSON.stringify(binding.sourceName)}`
+                : "")
+            }, ${varShared("rendered")}.returns[${this.#getRenderId(
               binding.node
             )}]${binding.objectPath || ""}]${SEP_COMMA_NEW_LINE}`
           );
@@ -2122,29 +2247,40 @@ constructor(_?: Return) {}
     const renderId = this.#getRenderId(tag);
     if (renderId) {
       this.#extractor.write(
-        `${varShared("assertRendered")}(${varShared(
-          "rendered"
-        )}, ${renderId}, `
+        `${varShared("assertRendered")}(${varShared("rendered")}, ${renderId}, `
       );
     }
     if (tagName) {
       const def = this.#lookup.getTag(tagName);
       if (def) {
         const importPath = resolveTagImport(this.#filename, def);
-        const renderer = (importPath == null ? void 0 : importPath.endsWith(".marko")) ? `renderTemplate(import("${importPath}"))` : def.html ? `renderNativeTag("${def.name}")` : "missingTag";
+        const renderer = (
+          importPath == null ? void 0 : importPath.endsWith(".marko")
+        )
+          ? `renderTemplate(import("${importPath}"))`
+          : def.html
+          ? `renderNativeTag("${def.name}")`
+          : "missingTag";
         if (!def.html && isValidIdentifier(tagName)) {
-          this.#extractor.write(
-            `${varShared("renderPreferLocal")}(
+          this.#extractor
+            .write(
+              `${varShared("renderPreferLocal")}(
 // @ts-expect-error We expect the compiler to error because we are checking if the tag is defined.
 (${varShared("error")}, `
-          ).copy(tag.name).write(`),
+            )
+            .copy(tag.name).write(`),
 ${varShared(renderer)})`);
         } else {
           this.#extractor.write(varShared(renderer));
         }
       } else if (isValidIdentifier(tagName)) {
-        this.#extractor.write(`${varShared("renderDynamicTag")}(
-`).copy(tag.name).write("\n)");
+        this.#extractor
+          .write(
+            `${varShared("renderDynamicTag")}(
+`
+          )
+          .copy(tag.name)
+          .write("\n)");
       } else {
         this.#extractor.write(`${varShared("missingTag")}`);
       }
@@ -2177,11 +2313,17 @@ ${varShared(renderer)})`);
     if (dynamicTagNameExpression) {
       this.#extractor.copy(dynamicTagNameExpression);
     } else {
-      this.#extractor.write(`${varShared("interpolated")}\``).copy(tag.name).write("`");
+      this.#extractor
+        .write(`${varShared("interpolated")}\``)
+        .copy(tag.name)
+        .write("`");
     }
   }
   #writeTagNameComment(tag) {
-    this.#extractor.write("/*").copy(this.#getDynamicTagExpression(tag) || tag.name).write("*/");
+    this.#extractor
+      .write("/*")
+      .copy(this.#getDynamicTagExpression(tag) || tag.name)
+      .write("*/");
   }
   #writePlaceholder(placeholder) {
     this.#writeComments(placeholder);
@@ -2196,10 +2338,13 @@ ${varShared(renderer)})`);
     let hasAttrs = false;
     if (tag.shorthandId) {
       hasAttrs = true;
-      this.#extractor.write(`id: ${varShared("interpolated")}\``).copy({
-        start: tag.shorthandId.start + 1,
-        end: tag.shorthandId.end
-      }).write("`" + SEP_COMMA_NEW_LINE);
+      this.#extractor
+        .write(`id: ${varShared("interpolated")}\``)
+        .copy({
+          start: tag.shorthandId.start + 1,
+          end: tag.shorthandId.end,
+        })
+        .write("`" + SEP_COMMA_NEW_LINE);
     }
     if (tag.shorthandClassNames) {
       let sep = SEP_EMPTY;
@@ -2208,7 +2353,7 @@ ${varShared(renderer)})`);
       for (const shorthandClassName of tag.shorthandClassNames) {
         this.#extractor.write(sep).copy({
           start: shorthandClassName.start + 1,
-          end: shorthandClassName.end
+          end: shorthandClassName.end,
         });
         sep = SEP_SPACE;
       }
@@ -2217,7 +2362,12 @@ ${varShared(renderer)})`);
     let attrWhitespaceStart = Math.max(
       tag.name.end,
       ((_a = tag.shorthandId) == null ? void 0 : _a.end) ?? -1,
-      ((_c = (_b = tag.shorthandClassNames) == null ? void 0 : _b[tag.shorthandClassNames.length - 1]) == null ? void 0 : _c.end) ?? -1,
+      ((_c =
+        (_b = tag.shorthandClassNames) == null
+          ? void 0
+          : _b[tag.shorthandClassNames.length - 1]) == null
+        ? void 0
+        : _c.end) ?? -1,
       ((_d = tag.var) == null ? void 0 : _d.end) ?? -1,
       ((_e = tag.args) == null ? void 0 : _e.end) ?? -1,
       ((_f = tag.params) == null ? void 0 : _f.end) ?? -1
@@ -2238,7 +2388,10 @@ ${varShared(renderer)})`);
           case 10 /* AttrNamed */: {
             const isDefault = isEmptyRange(attr.name);
             const value = attr.value;
-            const modifierIndex = !isDefault && (!value || value.type === 13 /* AttrValue */) && this.#getNamedAttrModifierIndex(attr);
+            const modifierIndex =
+              !isDefault &&
+              (!value || value.type === 13) /* AttrValue */ &&
+              this.#getNamedAttrModifierIndex(attr);
             const defaultMapPosition = isDefault ? attr.name : void 0;
             let name = isDefault ? ATTR_UNAMED2 : attr.name;
             if (modifierIndex !== false) {
@@ -2247,40 +2400,85 @@ ${varShared(renderer)})`);
             if (value) {
               switch (value.type) {
                 case 14 /* AttrMethod */:
-                  this.#extractor.write('"').copy(defaultMapPosition).copy(name).write('"').copy(value.typeParams);
+                  this.#extractor
+                    .write('"')
+                    .copy(defaultMapPosition)
+                    .copy(name)
+                    .write('"')
+                    .copy(value.typeParams);
                   this.#copyWithMutationsReplaced(value.params);
                   this.#copyWithMutationsReplaced(value.body);
                   break;
                 case 13 /* AttrValue */:
-                  this.#extractor.write('"').copy(defaultMapPosition).copy(name).write('": (\n');
+                  this.#extractor
+                    .write('"')
+                    .copy(defaultMapPosition)
+                    .copy(name)
+                    .write('": (\n');
                   if (value.bound) {
-                    const memberExpressionStart = getBoundAttrMemberExpressionStartOffset(value);
+                    const memberExpressionStart =
+                      getBoundAttrMemberExpressionStartOffset(value);
                     if (memberExpressionStart === void 0) {
                       const valueLiteral = this.#read(value.value);
-                      this.#extractor.copy(value.value).write(`
-)${SEP_COMMA_NEW_LINE}"`).copy(defaultMapPosition).copy(name).write(
-                        `Change"(_${valueLiteral}) {
-${isMutatedVar(tag.parent, valueLiteral) ? `${varLocal("return")}.mutate.` : ""}`
-                      ).copy(value.value).write(`= _${valueLiteral};
+                      this.#extractor
+                        .copy(value.value)
+                        .write(
+                          `
+)${SEP_COMMA_NEW_LINE}"`
+                        )
+                        .copy(defaultMapPosition)
+                        .copy(name)
+                        .write(
+                          `Change"(_${valueLiteral}) {
+${
+  isMutatedVar(tag.parent, valueLiteral) ? `${varLocal("return")}.mutate.` : ""
+}`
+                        )
+                        .copy(value.value).write(`= _${valueLiteral};
 }`);
                     } else if (this.#code[memberExpressionStart] === "[") {
                       const memberObjectRange = {
                         start: value.value.start,
-                        end: memberExpressionStart + 1
+                        end: memberExpressionStart + 1,
                       };
                       const memberPropertyRange = {
                         start: memberObjectRange.end,
-                        end: value.value.end - 1
+                        end: value.value.end - 1,
                       };
                       const memberPropertyCloseRange = {
                         start: memberPropertyRange.end,
-                        end: value.value.end
+                        end: value.value.end,
                       };
-                      this.#extractor.copy(memberObjectRange).copy(memberPropertyRange).copy(memberPropertyCloseRange).write(`
-)${SEP_COMMA_NEW_LINE}"`).copy(defaultMapPosition).copy(name).write('Change": (\n').copy(memberObjectRange).write("\n`${\n").copy(memberPropertyRange).write("\n}Change`\n").copy(memberPropertyCloseRange).write("\n)");
+                      this.#extractor
+                        .copy(memberObjectRange)
+                        .copy(memberPropertyRange)
+                        .copy(memberPropertyCloseRange)
+                        .write(
+                          `
+)${SEP_COMMA_NEW_LINE}"`
+                        )
+                        .copy(defaultMapPosition)
+                        .copy(name)
+                        .write('Change": (\n')
+                        .copy(memberObjectRange)
+                        .write("\n`${\n")
+                        .copy(memberPropertyRange)
+                        .write("\n}Change`\n")
+                        .copy(memberPropertyCloseRange)
+                        .write("\n)");
                     } else {
-                      this.#extractor.copy(value.value).write(`
-)${SEP_COMMA_NEW_LINE}"`).copy(defaultMapPosition).copy(name).write('Change"').write(": ").copy(value.value).write(`Change`);
+                      this.#extractor
+                        .copy(value.value)
+                        .write(
+                          `
+)${SEP_COMMA_NEW_LINE}"`
+                        )
+                        .copy(defaultMapPosition)
+                        .copy(name)
+                        .write('Change"')
+                        .write(": ")
+                        .copy(value.value)
+                        .write(`Change`);
                     }
                   } else {
                     this.#copyWithMutationsReplaced(value.value);
@@ -2290,7 +2488,10 @@ ${isMutatedVar(tag.parent, valueLiteral) ? `${varLocal("return")}.mutate.` : ""}
               }
             } else if (attr.args) {
               this.#extractor.write('"').copy(name).write('": ');
-              if (typeof name !== "string" && this.#read(name).startsWith("on")) {
+              if (
+                typeof name !== "string" &&
+                this.#read(name).startsWith("on")
+              ) {
                 const stringLiteralFirstArgMatch = this.#execAtIndex(
                   REG_ATTR_ARG_LITERAL,
                   attr.args.value.start
@@ -2306,29 +2507,46 @@ ${isMutatedVar(tag.parent, valueLiteral) ? `${varLocal("return")}.mutate.` : ""}
                     const propertNameStart = stringLiteralStart + 1;
                     this.#extractor.write("component.").copy({
                       start: propertNameStart,
-                      end: propertNameStart + stringLiteralValue.length
+                      end: propertNameStart + stringLiteralValue.length,
                     });
                   } else {
-                    this.#extractor.write(`component[`).copy({
-                      start: stringLiteralStart,
-                      end: stringLiteralStart + stringLiteralValue.length + 2
-                    }).write("]");
+                    this.#extractor
+                      .write(`component[`)
+                      .copy({
+                        start: stringLiteralStart,
+                        end: stringLiteralStart + stringLiteralValue.length + 2,
+                      })
+                      .write("]");
                   }
                   if (hasPartialArgs) {
-                    this.#extractor.write(`.bind(component, `).copy({
-                      start: stringLiteralStart + stringLiteralFirstArgMatch[0].length,
-                      end: attr.args.value.end
-                    }).write(")");
+                    this.#extractor
+                      .write(`.bind(component, `)
+                      .copy({
+                        start:
+                          stringLiteralStart +
+                          stringLiteralFirstArgMatch[0].length,
+                        end: attr.args.value.end,
+                      })
+                      .write(")");
                   }
                 } else {
-                  this.#extractor.write(`${varShared("bind")}(component, 
-`).copy(attr.args.value).write("\n)");
+                  this.#extractor
+                    .write(
+                      `${varShared("bind")}(component, 
+`
+                    )
+                    .copy(attr.args.value)
+                    .write("\n)");
                 }
               } else {
                 this.#extractor.copy(attr.args);
               }
             } else {
-              this.#extractor.write('"').copy(defaultMapPosition).copy(name).write(`": ${modifierIndex === false ? "true" : '""'}`);
+              this.#extractor
+                .write('"')
+                .copy(defaultMapPosition)
+                .copy(name)
+                .write(`": ${modifierIndex === false ? "true" : '""'}`);
             }
             break;
           }
@@ -2338,7 +2556,14 @@ ${isMutatedVar(tag.parent, valueLiteral) ? `${varLocal("return")}.mutate.` : ""}
     }
     this.#copyWhitespaceWithin(
       attrWhitespaceStart,
-      tag.open.end - (tag.concise ? this.#code[tag.open.end] === ";" ? 1 : 0 : tag.selfClosed ? 2 : 1)
+      tag.open.end -
+        (tag.concise
+          ? this.#code[tag.open.end] === ";"
+            ? 1
+            : 0
+          : tag.selfClosed
+          ? 2
+          : 1)
     );
     return hasAttrs;
   }
@@ -2364,18 +2589,14 @@ ${isMutatedVar(tag.parent, valueLiteral) ? `${varLocal("return")}.mutate.` : ""}
     }
     if (dynamicAttrTagParents) {
       this.#writeDynamicAttrTagParents(dynamicAttrTagParents);
-      if (wasMerge)
-        this.#extractor.write(`)${SEP_COMMA_NEW_LINE}`);
+      if (wasMerge) this.#extractor.write(`)${SEP_COMMA_NEW_LINE}`);
     }
   }
   #writeStaticAttrTags(staticAttrTags, wasMerge) {
-    if (!wasMerge)
-      this.#extractor.write("...{");
+    if (!wasMerge) this.#extractor.write("...{");
     this.#extractor.write(
       `[${varShared("never")}](){
-const attrTags = ${varShared(
-        "attrTagNames"
-      )}(this);
+const attrTags = ${varShared("attrTagNames")}(this);
 `
     );
     for (const nameText in staticAttrTags) {
@@ -2386,15 +2607,21 @@ const attrTags = ${varShared(
       }
     }
     this.#extractor.write("\n}");
-    if (!wasMerge)
-      this.#extractor.write("}");
+    if (!wasMerge) this.#extractor.write("}");
     this.#extractor.write(SEP_COMMA_NEW_LINE);
     for (const nameText in staticAttrTags) {
       const attrTag = staticAttrTags[nameText];
       const attrTagDef = this.#lookup.getTag(nameText);
-      const isRepeated = attrTag.length > 1 ? true : attrTagDef == null ? void 0 : attrTagDef.isRepeated;
+      const isRepeated =
+        attrTag.length > 1
+          ? true
+          : attrTagDef == null
+          ? void 0
+          : attrTagDef.isRepeated;
       const [firstAttrTag] = attrTag;
-      const name = (attrTagDef == null ? void 0 : attrTagDef.targetProperty) || nameText.slice(nameText.lastIndexOf(":") + 1);
+      const name =
+        (attrTagDef == null ? void 0 : attrTagDef.targetProperty) ||
+        nameText.slice(nameText.lastIndexOf(":") + 1);
       this.#extractor.write(`["${name}"`);
       this.#writeTagNameComment(firstAttrTag);
       this.#extractor.write("]: ");
@@ -2417,9 +2644,16 @@ const attrTags = ${varShared(
         case "if": {
           const alternates = IF_TAG_ALTERNATES.get(tag);
           this.#writeComments(tag);
-          this.#extractor.write("((\n").copy(
-            this.#getRangeWithoutTrailingComma((_a = tag.args) == null ? void 0 : _a.value) || this.#getAttrValue(tag, ATTR_UNAMED2) || "undefined"
-          ).write("\n) ? ");
+          this.#extractor
+            .write("((\n")
+            .copy(
+              this.#getRangeWithoutTrailingComma(
+                (_a = tag.args) == null ? void 0 : _a.value
+              ) ||
+                this.#getAttrValue(tag, ATTR_UNAMED2) ||
+                "undefined"
+            )
+            .write("\n) ? ");
           this.#writeDynamicAttrTagBody(tag);
           let needsAlternate = true;
           if (alternates) {
@@ -2445,21 +2679,31 @@ const attrTags = ${varShared(
         case "for": {
           this.#extractor.write(`${varShared("forAttrTag")}({
 `);
-          if (!this.#writeAttrs(tag))
-            this.#writeTagNameComment(tag);
+          if (!this.#writeAttrs(tag)) this.#writeTagNameComment(tag);
           this.#extractor.write("}, \n");
           this.#writeComments(tag);
-          this.#extractor.copy(tag.typeParams).write("(\n").copy((_b = tag.params) == null ? void 0 : _b.value).write("\n) => (");
+          this.#extractor
+            .copy(tag.typeParams)
+            .write("(\n")
+            .copy((_b = tag.params) == null ? void 0 : _b.value)
+            .write("\n) => (");
           this.#writeDynamicAttrTagBody(tag);
           this.#extractor.write("))");
           break;
         }
         case "while": {
           this.#writeComments(tag);
-          this.#extractor.write(`${varShared("mergeAttrTags")}((
-`).copy(
-            this.#getRangeWithoutTrailingComma((_c = tag.args) == null ? void 0 : _c.value) || "undefined"
-          ).write("\n) ? [");
+          this.#extractor
+            .write(
+              `${varShared("mergeAttrTags")}((
+`
+            )
+            .copy(
+              this.#getRangeWithoutTrailingComma(
+                (_c = tag.args) == null ? void 0 : _c.value
+              ) || "undefined"
+            )
+            .write("\n) ? [");
           this.#writeDynamicAttrTagBody(tag);
           this.#extractor.write("] : [])");
           break;
@@ -2469,19 +2713,26 @@ const attrTags = ${varShared(
     }
   }
   #writeTagInputObject(tag) {
-    if (!tag.params)
-      this.#writeComments(tag);
+    if (!tag.params) this.#writeComments(tag);
     let hasInput = false;
     this.#extractor.write("{\n");
     if (tag.args) {
       hasInput = true;
-      this.#extractor.write("[").copy({
-        start: tag.args.start,
-        end: tag.args.start + 1
-      }).write('"value"').copy({
-        start: tag.args.end - 1,
-        end: tag.args.end
-      }).write(`]: ${varShared("tuple")}(`).copy(tag.args.value).write(")").write(",\n");
+      this.#extractor
+        .write("[")
+        .copy({
+          start: tag.args.start,
+          end: tag.args.start + 1,
+        })
+        .write('"value"')
+        .copy({
+          start: tag.args.end - 1,
+          end: tag.args.end,
+        })
+        .write(`]: ${varShared("tuple")}(`)
+        .copy(tag.args.value)
+        .write(")")
+        .write(",\n");
     }
     if (this.#writeAttrs(tag)) {
       hasInput = true;
@@ -2510,7 +2761,9 @@ const attrTags = ${varShared(
 `);
       }
       const localBindings = getHoistSources(tag);
-      const didReturn = (body == null ? void 0 : body.renderBody) && this.#writeChildren(tag, body.renderBody);
+      const didReturn =
+        (body == null ? void 0 : body.renderBody) &&
+        this.#writeChildren(tag, body.renderBody);
       if (!tag.params) {
         this.#extractor.write(`return () => {
 `);
@@ -2527,7 +2780,10 @@ const attrTags = ${varShared(
       this.#extractor.write(SEP_COMMA_NEW_LINE);
     }
     if (tag.type === 16 /* AttrTag */) {
-      this.#extractor.write("[/*").copy(tag.name).write(`*/Symbol.iterator]: ${varShared("any")}${SEP_COMMA_NEW_LINE}`);
+      this.#extractor
+        .write("[/*")
+        .copy(tag.name)
+        .write(`*/Symbol.iterator]: ${varShared("any")}${SEP_COMMA_NEW_LINE}`);
     }
     if (!hasInput) {
       this.#writeTagNameComment(tag);
@@ -2542,19 +2798,20 @@ const attrTags = ${varShared(
     this.#extractor.write("}");
   }
   #getCastedType(type) {
-    return this.#scriptLang === "ts" /* ts */ ? `${varShared("any")} as ${type}` : `/** @type {${type}} */(${varShared("any")})`;
+    return this.#scriptLang === "ts" /* ts */
+      ? `${varShared("any")} as ${type}`
+      : `/** @type {${type}} */(${varShared("any")})`;
   }
   #copyWithMutationsReplaced(range) {
     const mutations = this.#mutationOffsets;
-    if (!mutations)
-      return this.#extractor.copy(range);
+    if (!mutations) return this.#extractor.copy(range);
     const len = mutations.length;
     let curOffset = range.start;
     let minIndex = 0;
     do {
       let maxIndex = len;
       while (minIndex < maxIndex) {
-        const midIndex = minIndex + maxIndex >>> 1;
+        const midIndex = (minIndex + maxIndex) >>> 1;
         if (mutations[midIndex] >= curOffset) {
           maxIndex = midIndex;
         } else {
@@ -2565,7 +2822,7 @@ const attrTags = ${varShared(
       if (nextOffset >= range.end) {
         this.#extractor.copy({
           start: curOffset,
-          end: range.end
+          end: range.end,
         });
         return;
       }
@@ -2597,8 +2854,7 @@ const attrTags = ${varShared(
   #processBody(parent) {
     var _a;
     const { body } = parent;
-    if (!body)
-      return;
+    if (!body) return;
     const last = body.length - 1;
     let renderBody;
     let staticAttrTags;
@@ -2631,56 +2887,56 @@ const attrTags = ${varShared(
             case "if": {
               let alternates;
               hasDynamicAttrTags ||= child.hasAttrTags;
-              loop:
-                while (i <= last) {
-                  const nextChild = body[i++];
-                  switch (nextChild.type) {
-                    case 17 /* Text */:
-                      if (this.#isEmptyText(nextChild)) {
-                        continue loop;
-                      } else {
-                        break;
-                      }
-                    case 1 /* Tag */:
-                      switch (nextChild.nameText) {
-                        case "else-if": {
-                          const alternate = {
-                            condition: this.#getRangeWithoutTrailingComma(
+              loop: while (i <= last) {
+                const nextChild = body[i++];
+                switch (nextChild.type) {
+                  case 17 /* Text */:
+                    if (this.#isEmptyText(nextChild)) {
+                      continue loop;
+                    } else {
+                      break;
+                    }
+                  case 1 /* Tag */:
+                    switch (nextChild.nameText) {
+                      case "else-if": {
+                        const alternate = {
+                          condition:
+                            this.#getRangeWithoutTrailingComma(
                               (_a = nextChild.args) == null ? void 0 : _a.value
                             ) || this.#getAttrValue(nextChild, ATTR_UNAMED2),
-                            node: nextChild
-                          };
-                          hasDynamicAttrTags ||= nextChild.hasAttrTags;
-                          if (alternates) {
-                            alternates.push(alternate);
-                          } else {
-                            alternates = [alternate];
-                          }
-                          continue loop;
+                          node: nextChild,
+                        };
+                        hasDynamicAttrTags ||= nextChild.hasAttrTags;
+                        if (alternates) {
+                          alternates.push(alternate);
+                        } else {
+                          alternates = [alternate];
                         }
-                        case "else": {
-                          const alternate = {
-                            condition: this.#getAttrValue(nextChild, "if"),
-                            node: nextChild
-                          };
-                          hasDynamicAttrTags ||= nextChild.hasAttrTags;
-                          if (alternates) {
-                            alternates.push(alternate);
-                          } else {
-                            alternates = [alternate];
-                          }
-                          if (alternate.condition) {
-                            continue loop;
-                          } else {
-                            break loop;
-                          }
+                        continue loop;
+                      }
+                      case "else": {
+                        const alternate = {
+                          condition: this.#getAttrValue(nextChild, "if"),
+                          node: nextChild,
+                        };
+                        hasDynamicAttrTags ||= nextChild.hasAttrTags;
+                        if (alternates) {
+                          alternates.push(alternate);
+                        } else {
+                          alternates = [alternate];
+                        }
+                        if (alternate.condition) {
+                          continue loop;
+                        } else {
+                          break loop;
                         }
                       }
-                      break;
-                  }
-                  i--;
-                  break;
+                    }
+                    break;
                 }
+                i--;
+                break;
+              }
               IF_TAG_ALTERNATES.set(child, alternates);
             }
           }
@@ -2741,15 +2997,17 @@ const attrTags = ${varShared(
   #getAttrValue(tag, name) {
     if (tag.attrs) {
       for (const attr of tag.attrs) {
-        if (isValueAttribute(attr) && (this.#read(attr.name) || ATTR_UNAMED2) === name) {
+        if (
+          isValueAttribute(attr) &&
+          (this.#read(attr.name) || ATTR_UNAMED2) === name
+        ) {
           return attr.value.value;
         }
       }
     }
   }
   #getRangeWithoutTrailingComma(range) {
-    if (!range)
-      return void 0;
+    if (!range) return void 0;
     const { start } = range;
     let end = range.end - 1;
     while (end >= start) {
@@ -2774,7 +3032,9 @@ const attrTags = ${varShared(
     return true;
   }
   #getInputType(program) {
-    return this.#scriptLang === "ts" /* ts */ ? this.#getTSInputType(program) : this.#ts && this.#getJSDocInputType(program);
+    return this.#scriptLang === "ts" /* ts */
+      ? this.#getTSInputType(program)
+      : this.#ts && this.#getJSDocInputType(program);
   }
   #getTSInputType(program) {
     var _a;
@@ -2782,30 +3042,44 @@ const attrTags = ${varShared(
       if (node.type === 25 /* Export */) {
         const start = node.start + "export ".length;
         if (this.#testAtIndex(REG_INPUT_TYPE, start)) {
-          const [inputType] = this.#scriptParser.statementAt(start, this.#read({ start, end: node.end }));
+          const [inputType] = this.#scriptParser.statementAt(
+            start,
+            this.#read({ start, end: node.end })
+          );
           return {
-            typeParameters: (_a = inputType == null ? void 0 : inputType.typeParameters) == null ? void 0 : _a.params.map((param) => {
-              return {
-                name: param.name,
-                constraint: param.constraint ? this.#read(param.constraint) : void 0,
-                default: param.default ? this.#read(param.default) : void 0
-              };
-            })
+            typeParameters:
+              (_a = inputType == null ? void 0 : inputType.typeParameters) ==
+              null
+                ? void 0
+                : _a.params.map((param) => {
+                    return {
+                      name: param.name,
+                      constraint: param.constraint
+                        ? this.#read(param.constraint)
+                        : void 0,
+                      default: param.default
+                        ? this.#read(param.default)
+                        : void 0,
+                    };
+                  }),
           };
         }
       }
     }
   }
   #getJSDocInputType(program) {
-    return this.#getJSDocInputTypeFromNodes(program.static) || this.#getJSDocInputTypeFromNodes(program.body) || this.#getJSDocInputTypeFromNode(program);
+    return (
+      this.#getJSDocInputTypeFromNodes(program.static) ||
+      this.#getJSDocInputTypeFromNodes(program.body) ||
+      this.#getJSDocInputTypeFromNode(program)
+    );
   }
   #getJSDocInputTypeFromNodes(nodes) {
     for (const node of nodes) {
       const code = this.#read(node);
       code;
       const info = this.#getJSDocInputTypeFromNode(node);
-      if (info)
-        return info;
+      if (info) return info;
     }
   }
   #getJSDocInputTypeFromNode(node) {
@@ -2824,13 +3098,17 @@ const attrTags = ${varShared(
     }
   }
   #getDynamicTagExpression(tag) {
-    if (tag.name.expressions.length === 1 && isEmptyRange(tag.name.quasis[0]) && isEmptyRange(tag.name.quasis[1])) {
+    if (
+      tag.name.expressions.length === 1 &&
+      isEmptyRange(tag.name.quasis[0]) &&
+      isEmptyRange(tag.name.quasis[1])
+    ) {
       return tag.name.expressions[0].value;
     }
   }
   #getRenderId(tag) {
     let renderId = this.#renderIds.get(tag);
-    if (renderId === void 0 && tag.var || hasHoists(tag)) {
+    if ((renderId === void 0 && tag.var) || hasHoists(tag)) {
       renderId = this.#renderId++;
       this.#renderIds.set(tag, renderId);
     }
@@ -2840,8 +3118,7 @@ const attrTags = ${varShared(
     const start = attr.name.start + 1;
     const end = attr.name.end - 1;
     for (let i = end; i-- > start; ) {
-      if (this.#code.charAt(i) === ":")
-        return i;
+      if (this.#code.charAt(i) === ":") return i;
     }
     return false;
   }
@@ -2871,7 +3148,10 @@ function getReturnTag(parent) {
 }
 function isValueAttribute(attr) {
   var _a;
-  return attr.type === 10 /* AttrNamed */ && ((_a = attr.value) == null ? void 0 : _a.type) === 13 /* AttrValue */;
+  return (
+    attr.type === 10 /* AttrNamed */ &&
+    ((_a = attr.value) == null ? void 0 : _a.type) === 13 /* AttrValue */
+  );
 }
 function resolveTagImport(from, def) {
   const filename = resolveTagFile(def);
@@ -2906,15 +3186,14 @@ __export(project_exports, {
   getTagLookup: () => getTagLookup,
   getTypeLibs: () => getTypeLibs,
   setDefaultCompilerMeta: () => setDefaultCompilerMeta,
-  setDefaultTypePaths: () => setDefaultTypePaths
+  setDefaultTypePaths: () => setDefaultTypePaths,
 });
 import path2 from "path";
 import { createRequire } from "module";
 import { strip as stripJSONComments } from "@luxass/strip-json-comments";
 var defaultTypeLibs = {};
 var defaultMeta;
-var ignoreErrors = (_err) => {
-};
+var ignoreErrors = (_err) => {};
 var metaByDir = /* @__PURE__ */ new Map();
 var metaByCompiler = /* @__PURE__ */ new Map();
 function getCompiler(dir) {
@@ -2933,54 +3212,66 @@ function getTypeLibs(rootDir, ts, host) {
   var _a;
   const config = getConfig(rootDir);
   let typeLibs = config.cache.get(getTypeLibs);
-  if (typeLibs)
-    return typeLibs;
+  if (typeLibs) return typeLibs;
   const resolveTypeCompilerOptions = {
-    moduleResolution: ts.ModuleResolutionKind.Bundler
+    moduleResolution: ts.ModuleResolutionKind.Bundler,
   };
   const markoRunGeneratedTypesFile = path2.join(
     rootDir,
     ".marko-run/routes.d.ts"
   );
   const resolveFromFile = path2.join(rootDir, "_.d.ts");
-  const internalTypesFile = defaultTypeLibs.internalTypesFile || ((_a = ts.resolveTypeReferenceDirective(
-    "@marko/language-tools/marko.internal.d.ts",
-    resolveFromFile,
-    resolveTypeCompilerOptions,
-    host
-  ).resolvedTypeReferenceDirective) == null ? void 0 : _a.resolvedFileName);
-  const { resolvedTypeReferenceDirective: resolvedMarkoTypes } = ts.resolveTypeReferenceDirective(
-    config.translator.runtimeTypes || "marko",
-    resolveFromFile,
-    resolveTypeCompilerOptions,
-    host
-  );
-  const { resolvedTypeReferenceDirective: resolvedMarkoRunTypes } = ts.resolveTypeReferenceDirective(
-    "@marko/run",
-    resolveFromFile,
-    resolveTypeCompilerOptions,
-    host
-  );
-  const markoTypesFile = (resolvedMarkoTypes == null ? void 0 : resolvedMarkoTypes.resolvedFileName) || defaultTypeLibs.markoTypesFile;
-  const markoRunTypesFile = resolvedMarkoRunTypes == null ? void 0 : resolvedMarkoRunTypes.resolvedFileName;
+  const internalTypesFile =
+    defaultTypeLibs.internalTypesFile ||
+    ((_a = ts.resolveTypeReferenceDirective(
+      "@marko/language-tools/marko.internal.d.ts",
+      resolveFromFile,
+      resolveTypeCompilerOptions,
+      host
+    ).resolvedTypeReferenceDirective) == null
+      ? void 0
+      : _a.resolvedFileName);
+  const { resolvedTypeReferenceDirective: resolvedMarkoTypes } =
+    ts.resolveTypeReferenceDirective(
+      config.translator.runtimeTypes || "marko",
+      resolveFromFile,
+      resolveTypeCompilerOptions,
+      host
+    );
+  const { resolvedTypeReferenceDirective: resolvedMarkoRunTypes } =
+    ts.resolveTypeReferenceDirective(
+      "@marko/run",
+      resolveFromFile,
+      resolveTypeCompilerOptions,
+      host
+    );
+  const markoTypesFile =
+    (resolvedMarkoTypes == null
+      ? void 0
+      : resolvedMarkoTypes.resolvedFileName) || defaultTypeLibs.markoTypesFile;
+  const markoRunTypesFile =
+    resolvedMarkoRunTypes == null
+      ? void 0
+      : resolvedMarkoRunTypes.resolvedFileName;
   if (!internalTypesFile || !markoTypesFile) {
     throw new Error("Could not resolve marko type files.");
   }
   config.cache.set(
     getTypeLibs,
-    typeLibs = {
+    (typeLibs = {
       internalTypesFile,
       markoTypesFile,
       markoTypesCode: host.readFile(markoTypesFile) || "",
       markoRunTypesFile,
-      markoRunGeneratedTypesFile: host.fileExists(markoRunGeneratedTypesFile) ? markoRunGeneratedTypesFile : void 0
-    }
+      markoRunGeneratedTypesFile: host.fileExists(markoRunGeneratedTypesFile)
+        ? markoRunGeneratedTypesFile
+        : void 0,
+    })
   );
   return typeLibs;
 }
 function getScriptLang(fileName, defaultScriptLang, ts, host) {
-  if (fileName.endsWith(".d.marko"))
-    return "ts" /* ts */;
+  if (fileName.endsWith(".d.marko")) return "ts" /* ts */;
   const dir = path2.dirname(fileName);
   const config = getConfig(dir);
   const cache = config.cache.get(getScriptLang);
@@ -2997,22 +3288,30 @@ function getScriptLang(fileName, defaultScriptLang, ts, host) {
         if (configSource) {
           const config2 = tryParseJSONWithComments(configSource);
           if (config2) {
-            const definedScriptLang = config2["script-lang"] || config2.scriptLang;
+            const definedScriptLang =
+              config2["script-lang"] || config2.scriptLang;
             if (definedScriptLang !== void 0) {
-              scriptLang = definedScriptLang === "ts" /* ts */ ? "ts" /* ts */ : "js" /* js */;
+              scriptLang =
+                definedScriptLang === "ts" /* ts */
+                  ? "ts" /* ts */
+                  : "js" /* js */;
             }
           }
         }
-      } catch {
-      }
+      } catch {}
     }
     if (scriptLang === void 0) {
-      scriptLang = /[/\\]node_modules[/\\]/.test(dir) ? "js" /* js */ : defaultScriptLang;
+      scriptLang = /[/\\]node_modules[/\\]/.test(dir)
+        ? "js" /* js */
+        : defaultScriptLang;
     }
     if (cache) {
       cache.set(dir, scriptLang);
     } else {
-      config.cache.set(getScriptLang, /* @__PURE__ */ new Map([[dir, scriptLang]]));
+      config.cache.set(
+        getScriptLang,
+        /* @__PURE__ */ new Map([[dir, scriptLang]])
+      );
     }
   }
   return scriptLang;
@@ -3038,8 +3337,8 @@ function setDefaultCompilerMeta(compiler, config) {
     config: {
       ...config,
       cache: /* @__PURE__ */ new Map(),
-      translator
-    }
+      translator,
+    },
   };
   compiler.configure(defaultMeta.config);
 }
@@ -3076,8 +3375,8 @@ function loadMeta(dir) {
         config: {
           ...config,
           cache: /* @__PURE__ */ new Map(),
-          translator: require2(config.translator)
-        }
+          translator: require2(config.translator),
+        },
       };
       compiler.configure(cached.config);
       metaByCompiler.set(configPath, cached);
@@ -3104,7 +3403,10 @@ function getTagLookupForProject(meta, dir) {
     if (cache) {
       cache.set(dir, lookup);
     } else {
-      meta.config.cache.set(getTagLookupForProject, /* @__PURE__ */ new Map([[dir, lookup]]));
+      meta.config.cache.set(
+        getTagLookupForProject,
+        /* @__PURE__ */ new Map([[dir, lookup]])
+      );
     }
   }
   return lookup;
@@ -3129,31 +3431,38 @@ var processors_exports = {};
 __export(processors_exports, {
   create: () => create,
   extensions: () => extensions,
-  has: () => has
+  has: () => has,
 });
 
 // src/util/get-ext.ts
 function getExt(fileName) {
   const extIndex = fileName.lastIndexOf(".");
-  if (extIndex !== -1)
-    return fileName.slice(extIndex);
+  if (extIndex !== -1) return fileName.slice(extIndex);
 }
 
 // src/processors/marko.ts
 import path3 from "path";
 var isRemapExtensionReg = /\.ts$/;
-var skipRemapExtensionsReg = /\.(?:[cm]?jsx?|json|marko|css|less|sass|scss|styl|stylus|pcss|postcss|sss|a?png|jpe?g|jfif|pipeg|pjp|gif|svg|ico|web[pm]|avif|mp4|ogg|mp3|wav|flac|aac|opus|woff2?|eot|[ot]tf|webmanifest|pdf|txt)$/;
+var skipRemapExtensionsReg =
+  /\.(?:[cm]?jsx?|json|marko|css|less|sass|scss|styl|stylus|pcss|postcss|sss|a?png|jpe?g|jfif|pipeg|pjp|gif|svg|ico|web[pm]|avif|mp4|ogg|mp3|wav|flac|aac|opus|woff2?|eot|[ot]tf|webmanifest|pdf|txt)$/;
 var marko_default = {
   extension: ".marko",
   create({ ts, host, configFile }) {
-    const currentDirectory = host.getCurrentDirectory ? host.getCurrentDirectory() : ts.sys.getCurrentDirectory();
-    const defaultScriptLang = configFile && /tsconfig/g.test(configFile) ? "ts" /* ts */ : "js" /* js */;
+    const currentDirectory = host.getCurrentDirectory
+      ? host.getCurrentDirectory()
+      : ts.sys.getCurrentDirectory();
+    const defaultScriptLang =
+      configFile && /tsconfig/g.test(configFile)
+        ? "ts" /* ts */
+        : "js"; /* js */
     const runtimeTypes = getTypeLibs(currentDirectory, ts, host);
     const rootNames = [
       runtimeTypes.internalTypesFile,
-      runtimeTypes.markoTypesFile
+      runtimeTypes.markoTypesFile,
     ];
-    const getJSFileIfTSExists = (source, importer) => host.fileExists(path3.join(importer, "..", `${source}.ts`)) && `${source}.js`;
+    const getJSFileIfTSExists = (source, importer) =>
+      host.fileExists(path3.join(importer, "..", `${source}.ts`)) &&
+      `${source}.js`;
     const compileConfig = {
       output: "source",
       stripTypes: true,
@@ -3171,26 +3480,34 @@ var marko_default = {
                 var _a;
                 const { node } = decl;
                 const value = (_a = node.source) == null ? void 0 : _a.value;
-                const importKind = "importKind" in node ? node.importKind : void 0;
-                if ((value == null ? void 0 : value[0]) === "." && (!importKind || importKind === "value") && !skipRemapExtensionsReg.test(value)) {
+                const importKind =
+                  "importKind" in node ? node.importKind : void 0;
+                if (
+                  (value == null ? void 0 : value[0]) === "." &&
+                  (!importKind || importKind === "value") &&
+                  !skipRemapExtensionsReg.test(value)
+                ) {
                   const filename = decl.hub.file.opts.filename;
-                  const remap = isRemapExtensionReg.test(value) ? `${value.slice(0, -2)}js` : getJSFileIfTSExists(value, filename) || getJSFileIfTSExists(`${value}/index`, filename);
+                  const remap = isRemapExtensionReg.test(value)
+                    ? `${value.slice(0, -2)}js`
+                    : getJSFileIfTSExists(value, filename) ||
+                      getJSFileIfTSExists(`${value}/index`, filename);
                   if (remap) {
                     node.source.value = remap;
                   }
                 }
-              }
-            }
-          }
+              },
+            },
+          },
         ],
         caller: {
           name: "@marko/type-check",
           supportsStaticESM: true,
           supportsDynamicImport: true,
           supportsTopLevelAwait: true,
-          supportsExportNamespaceFrom: true
-        }
-      }
+          supportsExportNamespaceFrom: true,
+        },
+      },
     };
     if (runtimeTypes.markoRunTypesFile) {
       rootNames.push(runtimeTypes.markoRunTypesFile);
@@ -3203,10 +3520,16 @@ var marko_default = {
         return rootNames;
       },
       getScriptExtension(fileName) {
-        return getScriptLang(fileName, defaultScriptLang, ts, host) === "ts" /* ts */ ? ts.Extension.Ts : ts.Extension.Js;
+        return getScriptLang(fileName, defaultScriptLang, ts, host) ===
+          "ts" /* ts */
+          ? ts.Extension.Ts
+          : ts.Extension.Js;
       },
       getScriptKind(fileName) {
-        return getScriptLang(fileName, defaultScriptLang, ts, host) === "ts" /* ts */ ? ts.ScriptKind.TS : ts.ScriptKind.JS;
+        return getScriptLang(fileName, defaultScriptLang, ts, host) ===
+          "ts" /* ts */
+          ? ts.ScriptKind.TS
+          : ts.ScriptKind.JS;
       },
       extract(fileName, code) {
         const dir = path3.dirname(fileName);
@@ -3215,13 +3538,8 @@ var marko_default = {
           ts,
           parsed,
           lookup: getTagLookup(dir),
-          scriptLang: getScriptLang(
-            fileName,
-            defaultScriptLang,
-            ts,
-            host
-          ),
-          runtimeTypesCode: runtimeTypes.markoTypesCode
+          scriptLang: getScriptLang(fileName, defaultScriptLang, ts, host),
+          runtimeTypesCode: runtimeTypes.markoTypesCode,
         });
       },
       print({ extracted: { parsed } }) {
@@ -3234,7 +3552,9 @@ var marko_default = {
         var _a, _b, _c;
         let code = "";
         const nlChar = formatSettings.newLineCharacter;
-        const tabChar = formatSettings.convertTabsToSpaces ? " ".repeat(formatSettings.indentSize) : "	";
+        const tabChar = formatSettings.convertTabsToSpaces
+          ? " ".repeat(formatSettings.indentSize)
+          : "	";
         let defaultExport;
         let defaultExportId;
         let componentImpl;
@@ -3242,23 +3562,35 @@ var marko_default = {
         for (const statement of sourceFile.statements) {
           if (ts.isExportAssignment(statement)) {
             defaultExport = statement;
-            defaultExportId = ts.isIdentifier(statement.expression) ? statement.expression.escapedText : void 0;
-          } else if (ts.isClassDeclaration(statement) && ((_a = statement.name) == null ? void 0 : _a.escapedText) === "Component") {
+            defaultExportId = ts.isIdentifier(statement.expression)
+              ? statement.expression.escapedText
+              : void 0;
+          } else if (
+            ts.isClassDeclaration(statement) &&
+            ((_a = statement.name) == null ? void 0 : _a.escapedText) ===
+              "Component"
+          ) {
             componentImpl = statement;
-          } else if (ts.isFunctionDeclaration(statement) && ((_b = statement.name) == null ? void 0 : _b.escapedText) === "___marko_internal_template") {
+          } else if (
+            ts.isFunctionDeclaration(statement) &&
+            ((_b = statement.name) == null ? void 0 : _b.escapedText) ===
+              "___marko_internal_template"
+          ) {
             internalRenderImpl = statement;
           }
         }
         for (const statement of sourceFile.statements) {
-          if (statement === defaultExport || // skips the generated `export default ...`.
-          statement === componentImpl || // skips the generated `class {}` since it needs special processing.
-          statement === internalRenderImpl || // skips the internal template render code.
-          isExportComponentType(statement) || // skips the generated `export { type Component }`.
-          isImportComponentType(statement) || // skips the generated `import type Component from "..."`.
-          isExportEmptyInputType(statement) || // skips empty exported Input, eg `export type Input = {}` or `export interface Input {}`.
-          isExportInputTypeAsComponentInput(statement) || // skips outputing `export type Input = Component["input"]` since it's inferred.
-          defaultExportId && // If the `export default` was an identifier, we also remove the variable that declared the identifier.
-          isVariableStatementForName(statement, defaultExportId)) {
+          if (
+            statement === defaultExport || // skips the generated `export default ...`.
+            statement === componentImpl || // skips the generated `class {}` since it needs special processing.
+            statement === internalRenderImpl || // skips the internal template render code.
+            isExportComponentType(statement) || // skips the generated `export { type Component }`.
+            isImportComponentType(statement) || // skips the generated `import type Component from "..."`.
+            isExportEmptyInputType(statement) || // skips empty exported Input, eg `export type Input = {}` or `export interface Input {}`.
+            isExportInputTypeAsComponentInput(statement) || // skips outputing `export type Input = Component["input"]` since it's inferred.
+            (defaultExportId && // If the `export default` was an identifier, we also remove the variable that declared the identifier.
+              isVariableStatementForName(statement, defaultExportId))
+          ) {
             continue;
           }
           const printed = printer.printNode(
@@ -3266,34 +3598,55 @@ var marko_default = {
             statement,
             sourceFile
           );
-          if (!/^(?:import|export) /.test(printed))
-            code += "static ";
+          if (!/^(?:import|export) /.test(printed)) code += "static ";
           code += printed + nlChar;
         }
         if (componentImpl == null ? void 0 : componentImpl.members.length) {
           code += `class {${nlChar}`;
           for (const member of componentImpl.members) {
             if (ts.isPropertyDeclaration(member)) {
-              code += `${tabChar}declare ${printer.printNode(ts.EmitHint.Unspecified, member, sourceFile) + nlChar}`;
-            } else if (ts.isMethodDeclaration(member) || ts.isGetAccessorDeclaration(member) || ts.isSetAccessorDeclaration(member)) {
-              code += `${tabChar + printer.printNode(ts.EmitHint.Unspecified, member, sourceFile).replace(/;\s*$/, "")} { return ${castType("any")}; }${nlChar}`;
+              code += `${tabChar}declare ${
+                printer.printNode(ts.EmitHint.Unspecified, member, sourceFile) +
+                nlChar
+              }`;
+            } else if (
+              ts.isMethodDeclaration(member) ||
+              ts.isGetAccessorDeclaration(member) ||
+              ts.isSetAccessorDeclaration(member)
+            ) {
+              code += `${
+                tabChar +
+                printer
+                  .printNode(ts.EmitHint.Unspecified, member, sourceFile)
+                  .replace(/;\s*$/, "")
+              } { return ${castType("any")}; }${nlChar}`;
             } else if (ts.isIndexSignatureDeclaration(member)) {
-              code += tabChar + printer.printNode(ts.EmitHint.Unspecified, member, sourceFile) + nlChar;
+              code +=
+                tabChar +
+                printer.printNode(ts.EmitHint.Unspecified, member, sourceFile) +
+                nlChar;
             }
           }
           code += `}${nlChar}`;
         }
         if (internalRenderImpl) {
-          const returnType = (_c = typeChecker.getSignatureFromDeclaration(internalRenderImpl)) == null ? void 0 : _c.getReturnType();
+          const returnType =
+            (_c =
+              typeChecker.getSignatureFromDeclaration(internalRenderImpl)) ==
+            null
+              ? void 0
+              : _c.getReturnType();
           if (returnType) {
             const props = returnType.getProperties();
-            const valueType = props.length === 1 && props[0].name === "value" && typeChecker.getPropertyOfType(returnType, "value") || void 0;
+            const valueType =
+              (props.length === 1 &&
+                props[0].name === "value" &&
+                typeChecker.getPropertyOfType(returnType, "value")) ||
+              void 0;
             code += "<return ";
             if (valueType) {
               code += `= ${castType(
-                typeChecker.typeToString(
-                  typeChecker.getTypeOfSymbol(valueType)
-                )
+                typeChecker.typeToString(typeChecker.getTypeOfSymbol(valueType))
               )}`;
             } else {
               code += `...${castType(typeChecker.typeToString(returnType))}`;
@@ -3302,20 +3655,52 @@ var marko_default = {
           }
         }
         return { code };
-      }
+      },
     };
     function isImportComponentType(statement) {
       var _a, _b;
-      return ts.isImportDeclaration(statement) && ((_b = (_a = statement.importClause) == null ? void 0 : _a.name) == null ? void 0 : _b.escapedText) === "Component";
+      return (
+        ts.isImportDeclaration(statement) &&
+        ((_b = (_a = statement.importClause) == null ? void 0 : _a.name) == null
+          ? void 0
+          : _b.escapedText) === "Component"
+      );
     }
     function isExportInputTypeAsComponentInput(statement) {
-      return ts.isTypeAliasDeclaration(statement) && statement.name.escapedText === "Input" && ts.isIndexedAccessTypeNode(statement.type) && ts.isTypeReferenceNode(statement.type.objectType) && ts.isIdentifier(statement.type.objectType.typeName) && statement.type.objectType.typeName.escapedText === "Component" && ts.isLiteralTypeNode(statement.type.indexType) && ts.isStringLiteral(statement.type.indexType.literal) && statement.type.indexType.literal.text === "input";
+      return (
+        ts.isTypeAliasDeclaration(statement) &&
+        statement.name.escapedText === "Input" &&
+        ts.isIndexedAccessTypeNode(statement.type) &&
+        ts.isTypeReferenceNode(statement.type.objectType) &&
+        ts.isIdentifier(statement.type.objectType.typeName) &&
+        statement.type.objectType.typeName.escapedText === "Component" &&
+        ts.isLiteralTypeNode(statement.type.indexType) &&
+        ts.isStringLiteral(statement.type.indexType.literal) &&
+        statement.type.indexType.literal.text === "input"
+      );
     }
     function isExportEmptyInputType(statement) {
-      return ts.isTypeAliasDeclaration(statement) && statement.name.escapedText === "Input" && ts.isTypeLiteralNode(statement.type) && !statement.typeParameters && statement.type.members.length === 0 || ts.isInterfaceDeclaration(statement) && statement.name.escapedText === "Input" && !statement.heritageClauses && !statement.typeParameters && statement.members.length === 0;
+      return (
+        (ts.isTypeAliasDeclaration(statement) &&
+          statement.name.escapedText === "Input" &&
+          ts.isTypeLiteralNode(statement.type) &&
+          !statement.typeParameters &&
+          statement.type.members.length === 0) ||
+        (ts.isInterfaceDeclaration(statement) &&
+          statement.name.escapedText === "Input" &&
+          !statement.heritageClauses &&
+          !statement.typeParameters &&
+          statement.members.length === 0)
+      );
     }
     function isExportComponentType(statement) {
-      return ts.isExportDeclaration(statement) && statement.exportClause && ts.isNamedExports(statement.exportClause) && statement.exportClause.elements.length === 1 && statement.exportClause.elements[0].name.escapedText === "Component";
+      return (
+        ts.isExportDeclaration(statement) &&
+        statement.exportClause &&
+        ts.isNamedExports(statement.exportClause) &&
+        statement.exportClause.elements.length === 1 &&
+        statement.exportClause.elements[0].name.escapedText === "Component"
+      );
     }
     function isVariableStatementForName(statement, name) {
       if (ts.isVariableStatement(statement)) {
@@ -3326,7 +3711,7 @@ var marko_default = {
         }
       }
     }
-  }
+  },
 };
 function castType(type) {
   if (type === "any") {
@@ -3339,7 +3724,7 @@ function castType(type) {
 var extensions = [marko_default.extension];
 function create(options) {
   return {
-    [marko_default.extension]: marko_default.create(options)
+    [marko_default.extension]: marko_default.create(options),
   };
 }
 function has(fileName) {
@@ -3353,13 +3738,13 @@ function isDefinitionFile(fileName) {
 }
 
 // src/extractors/html/keywords.ts
-var builtinTagsRegex = /^(?:a(?:(?:bbr|cronym|ddress|pplet|r(?:ea|ticle)|side|udio))?|b(?:(?:ase(?:font)?|d[io]|gsound|ig|l(?:ink|ockquote)|ody|r|utton))?|c(?:a(?:nvas|ption)|enter|ite|o(?:de|l(?:group)?|mmand|ntent))|d(?:ata(?:list)?|d|e(?:l|tails)|fn|i(?:alog|r|v)|l|t)|e(?:lement|m(?:bed)?)|f(?:i(?:eldset|g(?:caption|ure))|o(?:nt|oter|rm)|rame(?:set)?)|h(?:1|2|3|4|5|6|ead(?:er)?|group|r|tml)|i(?:(?:frame|m(?:age|g)|n(?:put|s)|sindex))?|k(?:bd|eygen)|l(?:abel|egend|i(?:(?:nk|sting))?)|m(?:a(?:in|p|r(?:k|quee)|th)|e(?:nu(?:item)?|t(?:a|er))|ulticol)|n(?:av|extid|o(?:br|embed|frames|script))|o(?:bject|l|pt(?:group|ion)|utput)|p(?:(?:aram|icture|laintext|r(?:e|ogress)))?|q|r(?:bc?|p|tc?|uby)|s(?:(?:amp|cript|e(?:ction|lect)|hadow|lot|mall|ource|pa(?:cer|n)|t(?:r(?:ike|ong)|yle)|u(?:b|mmary|p)|vg))?|t(?:able|body|d|e(?:mplate|xtarea)|foot|h(?:ead)?|i(?:me|tle)|r(?:ack)?|t)|ul?|v(?:ar|ideo)|wbr|xmp)$/;
+var builtinTagsRegex =
+  /^(?:a(?:(?:bbr|cronym|ddress|pplet|r(?:ea|ticle)|side|udio))?|b(?:(?:ase(?:font)?|d[io]|gsound|ig|l(?:ink|ockquote)|ody|r|utton))?|c(?:a(?:nvas|ption)|enter|ite|o(?:de|l(?:group)?|mmand|ntent))|d(?:ata(?:list)?|d|e(?:l|tails)|fn|i(?:alog|r|v)|l|t)|e(?:lement|m(?:bed)?)|f(?:i(?:eldset|g(?:caption|ure))|o(?:nt|oter|rm)|rame(?:set)?)|h(?:1|2|3|4|5|6|ead(?:er)?|group|r|tml)|i(?:(?:frame|m(?:age|g)|n(?:put|s)|sindex))?|k(?:bd|eygen)|l(?:abel|egend|i(?:(?:nk|sting))?)|m(?:a(?:in|p|r(?:k|quee)|th)|e(?:nu(?:item)?|t(?:a|er))|ulticol)|n(?:av|extid|o(?:br|embed|frames|script))|o(?:bject|l|pt(?:group|ion)|utput)|p(?:(?:aram|icture|laintext|r(?:e|ogress)))?|q|r(?:bc?|p|tc?|uby)|s(?:(?:amp|cript|e(?:ction|lect)|hadow|lot|mall|ource|pa(?:cer|n)|t(?:r(?:ike|ong)|yle)|u(?:b|mmary|p)|vg))?|t(?:able|body|d|e(?:mplate|xtarea)|foot|h(?:ead)?|i(?:me|tle)|r(?:ack)?|t)|ul?|v(?:ar|ideo)|wbr|xmp)$/;
 function isHTMLTag(tag) {
   return builtinTagsRegex.test(tag);
 }
 function getAttributeValueType(value) {
-  if (value === void 0 || value[0] !== "=")
-    return void 0;
+  if (value === void 0 || value[0] !== "=") return void 0;
   value = value.substring(1).trim();
   switch (value) {
     case "NaN":
@@ -3413,13 +3798,16 @@ var HTMLExtractor = class {
   }
   #visitNode(node) {
     var _a;
-    let hasDynamicBody = false, hasDynamicAttrs = false, isDynamic = false;
+    let hasDynamicBody = false,
+      hasDynamicAttrs = false,
+      isDynamic = false;
     switch (node.type) {
       case 16 /* AttrTag */:
-        (_a = node.body) == null ? void 0 : _a.forEach((child) => {
-          if (this.#visitNode(child))
-            hasDynamicBody = true;
-        });
+        (_a = node.body) == null
+          ? void 0
+          : _a.forEach((child) => {
+              if (this.#visitNode(child)) hasDynamicBody = true;
+            });
         break;
       case 1 /* Tag */: {
         const nodeId = `${this.#nodeIdCounter++}`;
@@ -3434,10 +3822,11 @@ var HTMLExtractor = class {
         this.#extractor.copy(node);
         break;
       case 22 /* Placeholder */:
-        isDynamic = this.#read({
-          start: node.start + 1,
-          end: node.start + 2
-        }) === "!";
+        isDynamic =
+          this.#read({
+            start: node.start + 1,
+            end: node.start + 2,
+          }) === "!";
         this.#extractor.write("placeholder");
         break;
     }
@@ -3445,7 +3834,8 @@ var HTMLExtractor = class {
   }
   #writeTag(node, id) {
     const isDynamic = !node.nameText || !isHTMLTag(node.nameText);
-    let hasDynamicAttrs = false, hasDynamicBody = false;
+    let hasDynamicAttrs = false,
+      hasDynamicBody = false;
     if (!isDynamic) {
       ({ hasDynamicAttrs, hasDynamicBody } = this.#writeHTMLTag(node, id));
     } else {
@@ -3455,22 +3845,24 @@ var HTMLExtractor = class {
   }
   #writeHTMLTag(node, id) {
     var _a, _b;
-    let hasDynamicAttrs = false, hasDynamicBody = false;
+    let hasDynamicAttrs = false,
+      hasDynamicBody = false;
     this.#extractor.write("<");
     this.#extractor.copy(node.name);
     this.#extractor.write(` data-marko-node-id="${id}"`);
-    (_a = node.attrs) == null ? void 0 : _a.forEach((attr) => {
-      if (attr.type === 10 /* AttrNamed */)
-        this.#writeAttrNamed(attr);
-      else if (attr.type === 15 /* AttrSpread */)
-        hasDynamicAttrs = true;
-    });
+    (_a = node.attrs) == null
+      ? void 0
+      : _a.forEach((attr) => {
+          if (attr.type === 10 /* AttrNamed */) this.#writeAttrNamed(attr);
+          else if (attr.type === 15 /* AttrSpread */) hasDynamicAttrs = true;
+        });
     this.#extractor.write(">");
     if (!isVoidTag(node.nameText)) {
-      (_b = node.body) == null ? void 0 : _b.forEach((child) => {
-        if (this.#visitNode(child))
-          hasDynamicBody = true;
-      });
+      (_b = node.body) == null
+        ? void 0
+        : _b.forEach((child) => {
+            if (this.#visitNode(child)) hasDynamicBody = true;
+          });
       this.#extractor.write(`</${node.nameText}>`);
     }
     return { hasDynamicAttrs, hasDynamicBody };
@@ -3485,13 +3877,16 @@ var HTMLExtractor = class {
   #writeAttrNamed(attr) {
     this.#extractor.write(" ");
     this.#extractor.copy(attr.name);
-    if (attr.value === void 0 || attr.name.start === attr.name.end || attr.value.type === 14 /* AttrMethod */) {
+    if (
+      attr.value === void 0 ||
+      attr.name.start === attr.name.end ||
+      attr.value.type === 14 /* AttrMethod */
+    ) {
       return;
     }
     const valueString = this.#read(attr.value);
     const valueType = getAttributeValueType(valueString);
-    if (valueType === void 0)
-      return;
+    if (valueType === void 0) return;
     switch (valueType) {
       case 0 /* True */:
         break;
@@ -3499,7 +3894,7 @@ var HTMLExtractor = class {
         this.#extractor.write('="');
         this.#extractor.copy({
           start: attr.value.start + valueString.search(/[^=\s]/g),
-          end: attr.value.end
+          end: attr.value.end,
         });
         this.#extractor.write('"');
         break;
@@ -3507,7 +3902,7 @@ var HTMLExtractor = class {
         this.#extractor.write('="');
         this.#extractor.copy({
           start: attr.value.start + valueString.search(/[^=\s]/g) + 1,
-          end: attr.value.end - 1
+          end: attr.value.end - 1,
         });
         this.#extractor.write('"');
         break;
@@ -3552,5 +3947,5 @@ export {
   getLocation,
   getPosition,
   isDefinitionFile,
-  parse
+  parse,
 };
diff --git a/dist/parser.d.ts b/dist/parser.d.ts
index 0a19ed6b3322c1125015da9c20367bb75755c736..1336f0254e73404baa7a9f02d001fc28b7d27b07 100644
--- a/dist/parser.d.ts
+++ b/dist/parser.d.ts
@@ -2,226 +2,280 @@ import { type Range, type Ranges, TagType } from "htmljs-parser";
 export type Repeated<T> = [T, ...T[]] | [...T[], T] | [T, ...T[], T];
 export type Repeatable<T> = undefined | Repeated<T>;
 export declare const UNFINISHED: number;
-export { getLines, getPosition, getLocation, type Range, type Ranges, type Position, type Location, } from "htmljs-parser";
+export {
+  getLines,
+  getPosition,
+  getLocation,
+  type Range,
+  type Ranges,
+  type Position,
+  type Location,
+} from "htmljs-parser";
 export type Parsed = ReturnType<typeof parse>;
 export declare enum NodeType {
-    Program = 0,
-    Tag = 1,
-    OpenTagName = 2,
-    ShorthandId = 3,
-    ShorthandClassName = 4,
-    TagTypeArgs = 5,
-    TagTypeParams = 6,
-    TagVar = 7,
-    TagArgs = 8,
-    TagParams = 9,
-    AttrNamed = 10,
-    AttrName = 11,
-    AttrArgs = 12,
-    AttrValue = 13,
-    AttrMethod = 14,
-    AttrSpread = 15,
-    AttrTag = 16,
-    Text = 17,
-    CDATA = 18,
-    Doctype = 19,
-    Declaration = 20,
-    Comment = 21,
-    Placeholder = 22,
-    Scriptlet = 23,
-    Import = 24,
-    Export = 25,
-    Class = 26,
-    Style = 27,
-    Static = 28
+  Program = 0,
+  Tag = 1,
+  OpenTagName = 2,
+  ShorthandId = 3,
+  ShorthandClassName = 4,
+  TagTypeArgs = 5,
+  TagTypeParams = 6,
+  TagVar = 7,
+  TagArgs = 8,
+  TagParams = 9,
+  AttrNamed = 10,
+  AttrName = 11,
+  AttrArgs = 12,
+  AttrValue = 13,
+  AttrMethod = 14,
+  AttrSpread = 15,
+  AttrTag = 16,
+  Text = 17,
+  CDATA = 18,
+  Doctype = 19,
+  Declaration = 20,
+  Comment = 21,
+  Placeholder = 22,
+  Scriptlet = 23,
+  Import = 24,
+  Export = 25,
+  Class = 26,
+  Style = 27,
+  Static = 28,
 }
 export declare namespace Node {
-    type AnyNode = Program | Tag | OpenTagName | ShorthandId | ShorthandClassName | TagTypeArgs | TagTypeParams | TagVar | TagArgs | TagParams | AttrNamed | AttrName | AttrArgs | AttrValue | AttrMethod | AttrSpread | AttrTag | Text | CDATA | Doctype | Declaration | Comment | Placeholder | Scriptlet | Import | Export | Class | Style | Static;
-    type ParentNode = Program | Tag | AttrTag;
-    type StaticNode = Import | Export | Class | Style | Static;
-    type ParentTag = Tag | AttrTag;
-    type AttrNode = AttrNamed | AttrSpread;
-    type ControlFlowTag = Tag & {
-        nameText: "if" | "else" | "else-if" | "for" | "while";
-        bodyType: TagType.html;
-    };
-    type ChildNode = Tag | AttrTag | Text | Doctype | Declaration | CDATA | Placeholder | Scriptlet;
-    interface Commentable {
-        comments: Repeatable<Comment>;
-    }
-    interface Program extends Range, Commentable {
-        type: NodeType.Program;
-        parent: undefined;
-        static: StaticNode[];
-        body: ChildNode[];
-    }
-    interface Tag extends Range, Commentable {
-        type: NodeType.Tag;
-        parent: ParentNode;
-        owner: undefined;
-        concise: boolean;
-        selfClosed: boolean;
-        hasAttrTags: boolean;
-        open: Range;
-        close: Range | undefined;
-        nameText: string | undefined;
-        bodyType: Exclude<TagType, "statement">;
-        name: OpenTagName;
-        var: TagVar | undefined;
-        args: TagArgs | undefined;
-        params: TagParams | undefined;
-        shorthandId: ShorthandId | undefined;
-        shorthandClassNames: Repeatable<ShorthandClassName>;
-        typeArgs: TagTypeArgs | undefined;
-        typeParams: TagTypeParams | undefined;
-        attrs: Repeatable<AttrNode>;
-        body: Repeatable<ChildNode>;
-    }
-    interface AttrTag extends Range, Commentable {
-        type: NodeType.AttrTag;
-        parent: ParentTag;
-        owner: ParentTag | undefined;
-        concise: boolean;
-        selfClosed: boolean;
-        hasAttrTags: boolean;
-        open: Range;
-        close: Range | undefined;
-        nameText: string;
-        bodyType: TagType.html;
-        name: OpenTagName;
-        var: TagVar | undefined;
-        args: TagArgs | undefined;
-        params: TagParams | undefined;
-        shorthandId: ShorthandId | undefined;
-        shorthandClassNames: Repeatable<ShorthandClassName>;
-        typeArgs: TagTypeArgs | undefined;
-        typeParams: TagTypeParams | undefined;
-        attrs: Repeatable<AttrNode>;
-        body: Repeatable<ChildNode>;
-    }
-    interface OpenTagName extends Ranges.Template {
-        type: NodeType.OpenTagName;
-        parent: ParentTag;
-    }
-    interface ShorthandId extends Ranges.Template {
-        type: NodeType.ShorthandId;
-        parent: ParentTag;
-    }
-    interface ShorthandClassName extends Ranges.Template {
-        type: NodeType.ShorthandClassName;
-        parent: ParentTag;
-    }
-    interface TagTypeArgs extends Ranges.Value {
-        type: NodeType.TagTypeArgs;
-        parent: ParentTag;
-    }
-    interface TagTypeParams extends Ranges.Value {
-        type: NodeType.TagTypeParams;
-        parent: ParentTag;
-    }
-    interface TagVar extends Ranges.Value {
-        type: NodeType.TagVar;
-        parent: ParentTag;
-    }
-    interface TagArgs extends Ranges.Value {
-        type: NodeType.TagArgs;
-        parent: ParentTag;
-    }
-    interface TagParams extends Ranges.Value {
-        type: NodeType.TagParams;
-        parent: ParentTag;
-    }
-    interface Text extends Range {
-        type: NodeType.Text;
-        parent: ParentNode;
-    }
-    interface CDATA extends Ranges.Value {
-        type: NodeType.CDATA;
-        parent: ParentNode;
-    }
-    interface Doctype extends Ranges.Value {
-        type: NodeType.Doctype;
-        parent: ParentNode;
-    }
-    interface Declaration extends Ranges.Value {
-        type: NodeType.Declaration;
-        parent: ParentNode;
-    }
-    interface Comment extends Ranges.Value {
-        type: NodeType.Comment;
-        parent: ParentNode;
-    }
-    interface Placeholder extends Ranges.Value, Commentable {
-        type: NodeType.Placeholder;
-        parent: ParentNode;
-        escape: boolean;
-    }
-    interface Scriptlet extends Ranges.Value, Commentable {
-        type: NodeType.Scriptlet;
-        parent: ParentNode;
-        block: boolean;
-    }
-    interface AttrNamed extends Range {
-        type: NodeType.AttrNamed;
-        parent: ParentTag;
-        name: AttrName;
-        args: undefined | AttrArgs;
-        value: undefined | AttrValue | AttrMethod;
-    }
-    interface AttrName extends Range {
-        type: NodeType.AttrName;
-        parent: AttrNamed;
-    }
-    interface AttrArgs extends Ranges.Value {
-        type: NodeType.AttrArgs;
-        parent: AttrNamed;
-    }
-    interface AttrValue extends Range {
-        type: NodeType.AttrValue;
-        parent: AttrNamed;
-        value: Range;
-        bound: boolean;
-    }
-    interface AttrMethod extends Range {
-        type: NodeType.AttrMethod;
-        parent: AttrNamed;
-        typeParams: undefined | Ranges.Value;
-        params: Range;
-        body: Range;
-    }
-    interface AttrSpread extends Ranges.Value {
-        type: NodeType.AttrSpread;
-        parent: ParentTag;
-    }
-    interface Import extends Range, Commentable {
-        type: NodeType.Import;
-        parent: ParentNode;
-    }
-    interface Export extends Range, Commentable {
-        type: NodeType.Export;
-        parent: ParentNode;
-    }
-    interface Class extends Range, Commentable {
-        type: NodeType.Class;
-        parent: ParentNode;
-    }
-    interface Style extends Range, Commentable {
-        type: NodeType.Style;
-        parent: ParentNode;
-        ext: string | undefined;
-        value: Range;
-    }
-    interface Static extends Range, Commentable {
-        type: NodeType.Static;
-        parent: ParentNode;
-    }
+  type AnyNode =
+    | Program
+    | Tag
+    | OpenTagName
+    | ShorthandId
+    | ShorthandClassName
+    | TagTypeArgs
+    | TagTypeParams
+    | TagVar
+    | TagArgs
+    | TagParams
+    | AttrNamed
+    | AttrName
+    | AttrArgs
+    | AttrValue
+    | AttrMethod
+    | AttrSpread
+    | AttrTag
+    | Text
+    | CDATA
+    | Doctype
+    | Declaration
+    | Comment
+    | Placeholder
+    | Scriptlet
+    | Import
+    | Export
+    | Class
+    | Style
+    | Static;
+  type ParentNode = Program | Tag | AttrTag;
+  type StaticNode = Import | Export | Class | Style | Static;
+  type ParentTag = Tag | AttrTag;
+  type AttrNode = AttrNamed | AttrSpread;
+  type ControlFlowTag = Tag & {
+    nameText: "if" | "else" | "else-if" | "for" | "while";
+    bodyType: TagType.html;
+  };
+  type ChildNode =
+    | Tag
+    | AttrTag
+    | Text
+    | Doctype
+    | Declaration
+    | CDATA
+    | Placeholder
+    | Scriptlet;
+  interface Commentable {
+    comments: Repeatable<Comment>;
+  }
+  interface Program extends Range, Commentable {
+    type: NodeType.Program;
+    parent: undefined;
+    static: StaticNode[];
+    body: ChildNode[];
+  }
+  interface Tag extends Range, Commentable {
+    type: NodeType.Tag;
+    parent: ParentNode;
+    owner: undefined;
+    concise: boolean;
+    selfClosed: boolean;
+    hasAttrTags: boolean;
+    open: Range;
+    close: Range | undefined;
+    nameText: string | undefined;
+    bodyType: Exclude<TagType, "statement">;
+    name: OpenTagName;
+    var: TagVar | undefined;
+    args: TagArgs | undefined;
+    params: TagParams | undefined;
+    shorthandId: ShorthandId | undefined;
+    shorthandClassNames: Repeatable<ShorthandClassName>;
+    typeArgs: TagTypeArgs | undefined;
+    typeParams: TagTypeParams | undefined;
+    attrs: Repeatable<AttrNode>;
+    body: Repeatable<ChildNode>;
+  }
+  interface AttrTag extends Range, Commentable {
+    type: NodeType.AttrTag;
+    parent: ParentTag;
+    owner: ParentTag | undefined;
+    concise: boolean;
+    selfClosed: boolean;
+    hasAttrTags: boolean;
+    open: Range;
+    close: Range | undefined;
+    nameText: string;
+    bodyType: TagType.html;
+    name: OpenTagName;
+    var: TagVar | undefined;
+    args: TagArgs | undefined;
+    params: TagParams | undefined;
+    shorthandId: ShorthandId | undefined;
+    shorthandClassNames: Repeatable<ShorthandClassName>;
+    typeArgs: TagTypeArgs | undefined;
+    typeParams: TagTypeParams | undefined;
+    attrs: Repeatable<AttrNode>;
+    body: Repeatable<ChildNode>;
+  }
+  interface OpenTagName extends Ranges.Template {
+    type: NodeType.OpenTagName;
+    parent: ParentTag;
+  }
+  interface ShorthandId extends Ranges.Template {
+    type: NodeType.ShorthandId;
+    parent: ParentTag;
+  }
+  interface ShorthandClassName extends Ranges.Template {
+    type: NodeType.ShorthandClassName;
+    parent: ParentTag;
+  }
+  interface TagTypeArgs extends Ranges.Value {
+    type: NodeType.TagTypeArgs;
+    parent: ParentTag;
+  }
+  interface TagTypeParams extends Ranges.Value {
+    type: NodeType.TagTypeParams;
+    parent: ParentTag;
+  }
+  interface TagVar extends Ranges.Value {
+    type: NodeType.TagVar;
+    parent: ParentTag;
+  }
+  interface TagArgs extends Ranges.Value {
+    type: NodeType.TagArgs;
+    parent: ParentTag;
+  }
+  interface TagParams extends Ranges.Value {
+    type: NodeType.TagParams;
+    parent: ParentTag;
+  }
+  interface Text extends Range {
+    type: NodeType.Text;
+    parent: ParentNode;
+  }
+  interface CDATA extends Ranges.Value {
+    type: NodeType.CDATA;
+    parent: ParentNode;
+  }
+  interface Doctype extends Ranges.Value {
+    type: NodeType.Doctype;
+    parent: ParentNode;
+  }
+  interface Declaration extends Ranges.Value {
+    type: NodeType.Declaration;
+    parent: ParentNode;
+  }
+  interface Comment extends Ranges.Value {
+    type: NodeType.Comment;
+    parent: ParentNode;
+  }
+  interface Placeholder extends Ranges.Value, Commentable {
+    type: NodeType.Placeholder;
+    parent: ParentNode;
+    escape: boolean;
+  }
+  interface Scriptlet extends Ranges.Value, Commentable {
+    type: NodeType.Scriptlet;
+    parent: ParentNode;
+    block: boolean;
+  }
+  interface AttrNamed extends Range {
+    type: NodeType.AttrNamed;
+    parent: ParentTag;
+    name: AttrName;
+    args: undefined | AttrArgs;
+    value: undefined | AttrValue | AttrMethod;
+  }
+  interface AttrName extends Range {
+    type: NodeType.AttrName;
+    parent: AttrNamed;
+  }
+  interface AttrArgs extends Ranges.Value {
+    type: NodeType.AttrArgs;
+    parent: AttrNamed;
+  }
+  interface AttrValue extends Range {
+    type: NodeType.AttrValue;
+    parent: AttrNamed;
+    value: Range;
+    bound: boolean;
+  }
+  interface AttrMethod extends Range {
+    type: NodeType.AttrMethod;
+    parent: AttrNamed;
+    typeParams: undefined | Ranges.Value;
+    params: Range;
+    body: Range;
+  }
+  interface AttrSpread extends Ranges.Value {
+    type: NodeType.AttrSpread;
+    parent: ParentTag;
+  }
+  interface Import extends Range, Commentable {
+    type: NodeType.Import;
+    parent: ParentNode;
+  }
+  interface Export extends Range, Commentable {
+    type: NodeType.Export;
+    parent: ParentNode;
+  }
+  interface Class extends Range, Commentable {
+    type: NodeType.Class;
+    parent: ParentNode;
+  }
+  interface Style extends Range, Commentable {
+    type: NodeType.Style;
+    parent: ParentNode;
+    ext: string | undefined;
+    value: Range;
+  }
+  interface Static extends Range, Commentable {
+    type: NodeType.Static;
+    parent: ParentNode;
+  }
 }
-export declare function parse(code: string, filename?: string): {
-    read: (range: Range) => string;
-    locationAt: (range: Range) => import("htmljs-parser").Location;
-    positionAt: (offset: number) => import("htmljs-parser").Position;
-    nodeAt: (offset: number) => Node.AnyNode;
-    filename: string;
-    program: Node.Program;
-    code: string;
+export declare function parse(
+  code: string,
+  filename?: string
+): {
+  read: (range: Range) => string;
+  locationAt: (range: Range) => import("htmljs-parser").Location;
+  positionAt: (offset: number) => import("htmljs-parser").Position;
+  nodeAt: (offset: number) => Node.AnyNode;
+  filename: string;
+  program: Node.Program;
+  code: string;
+  errors: {
+    code: import("htmljs-parser").ErrorCode;
+    message: string;
+    start: number;
+    end: number;
+  }[];
 };
diff --git a/dist/util/extractor.d.ts b/dist/util/extractor.d.ts
index 106b6d103ca810ce23514bb69ea15fe1186f4bee..6bc74c247e375a1a82e2f8ff4bb9a966f40ed361 100644
--- a/dist/util/extractor.d.ts
+++ b/dist/util/extractor.d.ts
@@ -1,29 +1,41 @@
-import { type Location, type Parsed, type Position, type Range } from "../parser";
+import {
+  type Location,
+  type Parsed,
+  type Position,
+  type Range,
+} from "../parser";
 interface Token {
-    generatedStart: number;
-    sourceStart: number;
-    length: number;
+  generatedStart: number;
+  sourceStart: number;
+  length: number;
 }
 /**
  * Utility to build up generate code from source ranges while maintaining a source mapping.
  */
 export declare class Extractor {
-    #private;
-    constructor(parsed: Parsed);
-    write(str: string): this;
-    copy(range: Range | string | false | void | undefined | null): this;
-    end(): Extracted;
+  #private;
+  constructor(parsed: Parsed);
+  write(str: string): this;
+  copy(range: Range | string | false | void | undefined | null): this;
+  end(): Extracted;
 }
 export declare class Extracted {
-    #private;
-    parsed: Parsed;
-    constructor(parsed: Parsed, generated: string, tokens: Token[]);
-    sourceOffsetAt(generatedOffset: number): number | undefined;
-    sourcePositionAt(generatedOffset: number): Position | undefined;
-    sourceLocationAt(generatedStart: number, generatedEnd: number): Location | undefined;
-    generatedOffsetAt(sourceOffset: number): number | undefined;
-    generatedPositionAt(sourceOffset: number): Position | undefined;
-    generatedLocationAt(sourceStart: number, sourceEnd: number): Location | undefined;
-    toString(): string;
+  #private;
+  parsed: Parsed;
+  tokens: Token[];
+  constructor(parsed: Parsed, generated: string, tokens: Token[]);
+  sourceOffsetAt(generatedOffset: number): number | undefined;
+  sourcePositionAt(generatedOffset: number): Position | undefined;
+  sourceLocationAt(
+    generatedStart: number,
+    generatedEnd: number
+  ): Location | undefined;
+  generatedOffsetAt(sourceOffset: number): number | undefined;
+  generatedPositionAt(sourceOffset: number): Position | undefined;
+  generatedLocationAt(
+    sourceStart: number,
+    sourceEnd: number
+  ): Location | undefined;
+  toString(): string;
 }
 export {};
